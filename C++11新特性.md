# C++11新特性

参考：https://subingwen.cn/cplusplus/

# 第一篇——稳定性和兼容性

# 1、原始字面量

在C++11中添加了定义原始字符串的字面量，定义方式为：`R “xxx(原始字符串)xxx”`其中（）两边的字符串可以省略。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

比如：编程过程中，使用的字符串中常带有一些特殊字符，对于这些字符往往要做专门的处理，使用了原始字面量就可以轻松的解决这个问题了，比如打印路径：

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "D:\hello\world\test.text";
    cout << str << endl;
    string str1 = "D:\\hello\\world\\test.text";
    cout << str1 << endl;
    string str2 = R"(D:\hello\world\test.text)";
    cout << str2 << endl;

    return 0;
}
```

输出的结果为:

```c++
D:helloworld    est.text
D:\hello\world\test.text
D:\hello\world\test.text
```

- 在`D:\hello\world\test.text`中`\h`和`\w`转义失败，对应的字符会原样输出
- 在`D:\\hello\\world\\test.text`中路径的间隔符为`\`但是这个字符又是转义字符，因此需要使用转义字符将其转义，最终才能得到一个没有特殊含义的普通字符`\`
- 在`R"(D:\hello\world\test.text)"`使用了**原始字面量R（）中的内容就是描述路径的原始字符串**，无需做任何处理

通过测试可以看到，使用原始字面量R可以直接得到其原始意义的字符串，再看一个输出HTML标签的例子：

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "<html>\
        <head>\
        <title>\
        海贼王\
        </title>\
        </head>\
        <body>\
        <p>\
        我是要成为海贼王的男人!!!\
        </p>\
        </body>\
        </html>";
    cout << str << endl;
    return 0;
}
```

在C++11之前如果一个字符串分别写到了不同的行里边，需要**加连接符**，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = R"(<html>
        <head>
        <title>
        海贼王
        </title>
        </head>
        <body>
        <p>
        我是要成为海贼王的男人!!!
        </p>
        </body>
        </html>)";
    cout << str << endl;

    return 0;
}
```

最后强调一个细节：`在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。`

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str1 = R"(D:\hello\world\test.text)";
    cout << str1 << endl;
    string str2 = R"luffy(D:\hello\world\test.text)luffy";
    cout << str2 << endl;
#if 0
    // 加在()两边字符串必须在括号两边同时出现
    string str3 = R"luffy(D:\hello\world\test.text)robin";	// 语法错误，编译不通过
    cout << str3 << endl;
#endif

    return 0;
}
```

测试代码输出的结果为：

```c++
D:\hello\world\test.text
D:\hello\world\test.text
```

通过输出的信息可以得到如下结论：**使用原始字面量R “xxx(raw string)xxx”，（）两边的字符串在解析的时候是会被忽略的，因此一般不用指定。如果在（）前后指定了字符串，那么前后的字符串必须相同，否则会出现语法错误**。

# 2、超长整形long long

相比于C++98标准，C++11整型的最大改变就是多了`long long`。但事实上，long long 整型本来就离C++标准很近，早在1995年，long long 就被提议写入 C++98标准，却被C++标准委员会拒绝了。而后来，long long类型却进入了C99标准，而且也事实上也被很多编译器支持。于是辗转地，C++标准委员会又掉头决定将 long long纳入 C++11标准。

## 2.1 long long 类型

C++11 标准要求 long long 整型可以在不同平台上有不同的长度，但`至少有64位`。long long 整型有两种∶

- **long long - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀**

  ```c++
  long long num1 = 123456789LL;
  long long num2 = 123456789ll;
  ```

- **unsigned long long - 对应类型的数值可以使用 ULL (大写) 或者 ull (小写) 或者 Ull、uLL (等大小写混合)后缀**

  ```c++
  unsigned long long num1 = 123456789ULL;
  unsigned long long num2 = 123456789ull;
  unsigned long long num3 = 123456789uLL;
  unsigned long long num4 = 123456789Ull;
  ```

事实上在C++11中还有一些类型与以上两种类型是等价的:

- 对于有符号类型的 **long long** 和以下三种类型等价
  - `long long int`
  - `signed long long`
  - `signed long long int`
- 对于无符号类型的`unsigned long long` 和`unsigned long long int`是等价的

同其他的整型一样，要了解平台上 long long大小的方法就是查看`<climits>`（或`<limits. h>` ）中的宏与long long整 型相关的一共有3个：

- `LLONG_MIN` - 最小的long long值
- `LLONG_MAX` - 最大的long long 值
- `ULLONG MAX` - 最大的 unsigned long long 值

测试代码如下:

```c++
#include <iostream>
using namespace std;

int main()
{
    long long max = LLONG_MAX;
    long long min = LLONG_MIN;
    unsigned long long ullMax = ULLONG_MAX;

    cout << "Max Long Long value: " << max << endl
        << "Min Long Long value: " << min << endl
        << "Max unsigned Long Long value: " << ullMax << endl;
    return 0;
}
```

程序输出的结果:

```c++
Max Long Long value: 9223372036854775807
Min Long Long value: -9223372036854775808
Max unsigned Long Long value: 18446744073709551615
```

**可以看到 long long 类型能够存储的最大/最小值还是非常大/小的，但是这个值根据平台不同会有所变化，原因是因为C++11标准规定该类型至少占8字节，它占的字节数越多，对应能够存储的数值也就越大**。

## 2.2 扩展的整形

在C++11中一共只定义了以下5种标准的**有符号整型**：

- `signed char`
- `short int`
- `int`
- `long int`
- `long long int`

标准同时规定，每一种有符号整型都有一种对应的无符号整数版本，且有符号整型与其对应的无符号整型具有相同的存储空间大小。比如与 signed int对应的无符号版本的整型是 unsigned int。

当我们在C++中处理数据的时候，如果参与运算的数据或者传递的参数类型不匹配，整型间会发生隐式的转换，这种过程通常被称为整型的提升。比如如下表达式∶

```c++
(int)num1 + (long long)num2
```

关于这种整形提升的隐式转换遵循如下**原则**:

- 长度越大的整型等级越高，比如 `long long int` 的等级会高于`int`。
- 长度相同的情况下，标准整型的等级高于扩展类型，比如 `long long int` 和 `int64` 如果 都是64 位长度，则`long long int`类型的等级更高。 
- 相同大小的有符号类型和无符号类型的等级相同，`long long int` 和`unsigned longlong  int`的等级就相同。
- 转换过程中，低等级整型需要转换为高等级整型，有符号的需要转换为无符号整形。

# 附录1——32位系统与64位系统各数据类型对比

下面是32位系统与64位系统各数据类型对比：

| 数据类型           | 说明           | 32位字节数 | 64位字节数 | 取值范围                             |
| ------------------ | -------------- | ---------- | ---------- | ------------------------------------ |
| bool               | 布尔型         | 1          | 1          | true，false                          |
| char               | 字符型         | 1          | 1          | -128~127                             |
| unsigned char      | 无符号字符型   | 1          | 1          | 0~255                                |
| short              | 短整型         | 2          | 2          | -32768~32767                         |
| unsigned short     | 无符号短整型   | 2          | 2          | 0~65535                              |
| int                | 整型           | 4          | 4          | -2147483648~2147483647               |
| unsigned int       | 无符号整型     | 4          | 4          | 0~4294967295                         |
| long               | 长整型         | `4`        | `8`        | –                                    |
| unsigned long      | 无符号长整型   | `4`        | `8`        | –                                    |
| unsigned long long | 无符号超长整型 | 至少8      | 至少8      | 8字节取值范围: 0 ~ 264               |
| float              | 单精度浮点数   | 4          | 4          | 范围-2128 ~ 2128 精度为6~7位有效数字 |
| double             | 双精度浮点数   | 8          | 8          | 范围-21024 ~ 21024 精度为15~16位     |
| long double        | 扩展精度浮点数 | 8          | 8          | 范围-21024 ~ 21024 精度为15~16位     |
| *                  | 地址（指针）   | `4`        | `8`        | –                                    |

# 3、类成员的快速初始化

## 3.1 C++98标准的类成员初始化

在C++98中，支持了在类声明中使用**==等号 = 加初始值==** 的方式，来初始化类中**==静态成员常量==** 。这种声明方式我们也称之为**”就地”声明**。而`非静态成员变量的初始化则必须在构造函数中进行。`

下面通过一段代码来举例说明:

```c++
struct Base 
{
    Base() : a(250) {}
    Base(int num) : a(num) {}

    int a;
    int b = 1;	
    static int c = 0;	
    static const double d = 3.14;	
    static const char* const e = "i am luffy";	
    const static int f = 0;	
};
```

如果按照 C++98 标准来解读上面这段代码 ，其中有这么几行语法是错误的：

- 第7行：类的非静态成员，必须在构造函数中进行初始化

- 第8行：类的静态成员，必须在类的外部进行初始化

- 第9行：类的静态常量成员，`但不是整形或者枚举，无法通过编译`

  如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对C++的一个扩展，并不遵从C++ 标准。

- 第10行：类的静态常量成员，`但不是整形或者枚举，无法通过编译`

- 第8、9、10行的变量初始化方式是一样的，都是在类的外部

  ```c++
  int Base::c = 110;
  const double Base::d = 3.14;
  const char* const Base::e = "i am luffy";
  ```

> ==**答疑解惑：上面程序中的 static const 和 const static 是等价的**==。

## 3.2 C++11标准的类成员初始化

### 3.2.1 初始化类的非静态成员

在进行类成员变量初始化的时候，C++11标准对于C++98做了补充，**允许在定义类的时候在类内部直接对非静态成员变量进行初始化**，在初始化的时候可**以使用等号 =** 也**可以使用花括号 {}** 。

```c++
class Test
{
private:
    int a = 9;
    int b = {5};
    int c{12};
    double array[4] = { 3.14, 3.15, 3.16, 3.17};
    double array1[4] { 3.14, 3.15, 3.16, 3.17 };
    string s1("hello");     // error，- 不能使用小括号() 初始化对象，应该使用花括号{}
    string s2{ "hello, world" };
};
```

可以看到如果使用`花括号 {}`的方式对类的非静态成员进行初始化，等号是可以省略不写的。

- 第9行：错误，不能使用小括号() 初始化对象，应该使用花括号{}

### 3.2.2 类内部赋值和初始化列表

在C++11之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）。那么，如果同时在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？下面来测试一下：

> 初始化列表在进入构造函数之前就已经对成员变量进行了初始化

```c++
class Init
{
public:
    Init(int x, int y, int z) :a(x), b(y), c(z) {}

    int a = 1;
    int b = 2;
    int c = 3;
};

int main()
{
    Init tmp(10, 20, 30);
    cout << "a: " << tmp.a << ", b: " << tmp.b << ", c: " << tmp.c << endl;
    return 0;
}
```

- 第4行：使用**初始化列表**对类的非静态成员进行初始化
- 第6、7、8行：在类内部对非静态成员变量**就地初始化**（C++11新特性）

执行程序，输出的结果如下：

```c++
a: 10, b: 20, c: 30
```

我们可以从函数的打印输出中看到，在类内部就地初始化和初始化列表并不冲突（程序可以正常运行）。程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来`后作用于`非静态成员。也就是说，通过初始化列表指定的值会覆盖就地初始化时指定的值。

# 4、final和override

## 4.1 final

C++中增加了`final`关键字来`限制某个类不能被继承，或者某个虚函数不能被重写`，和Java的final关键字的功能是类似的。如果使用`final`修饰函数，只能修饰虚函数，并且`要把final关键字放到类或者函数的后面。`

### 4.1.1 修饰函数

如果使用`final`修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了：

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout << "GrandChild class...";
    }
};
```

在上面的代码中一共有三个类：

- 基类：Base
- 子类：Child
- 孙子类：GrandChild

`test()`是基类中的一个虚函数，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将`test()`方法标记为`final`，孙子类中对这个方法就只有使用的份了。

### 4.1.2 修饰类

使用`final`关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child final: public Base
{
public:
    void test()
    {
        cout << "Child class...";
    }
};

// error, 语法错误
class GrandChild : public Child
{
public:
};
```

`Child`类是被`final`修饰过的，因此`Child`类不允许有派生类`GrandChild`类的继承是非法的，`Child`是个断子绝孙的类

## 4.2 override

`override`关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样`这个关键字要写到方法的后面`。使用方法如下：

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};
```

上述代码中第13行和第22行就是显示指定了要重写父类的`test()`方法，使用了`override`关键字之后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率。

# 5、模块的优化

## 5.1 模板的右尖括号

在泛型编程中，模板实例化有一个非常繁琐的地方，那就是连续的两个右尖括号（**>>**）会被编译器解析成右移操作符，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板`Base`中提供了遍历容器的操作函数`traversal()`:

```c++
// test.cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
class Base
{
public:
    void traversal(T& t)
    {
        auto it = t.begin();
        for (; it != t.end(); ++it)
        {
            cout << *it << " ";
        }
        cout << endl;
    }
};


int main()
{
    vector<int> v{ 1,2,3,4,5,6,7,8,9 };
    Base<vector<int>> b;
    b.traversal(v);

    return 0;
}
```

如果使用`C++98/03`标准来编译上边的这段代码，就会得到如下的错误提示：

```c++
test.cpp:25:20: error: '>>' should be '> >' within a nested template argument list
     Base<vector<int>> b;
```

根据错误提示中描述模板的两个右尖括之间需要添加空格，这样写起来就非常的麻烦，`C++11改进了编译器的解析规则，尽可能地将多个右尖括号（>）解析成模板参数结束符`，方便我们编写模板相关的代码。

上面的这段代码，在支持C++11的编译器中编译是没有任何问题的，如果使用g++直接编译需要加参数`-std=c++11`：

```shell
$ g++ test.cpp -std=c++11 -o app
```

## 5.2 默认模版参数

在`C++98/03`标准中，类模板可以有默认的模板参数：

```c++
#include <iostream>
using namespace std;

template <typename T=int, T t=520>
class Test
{
public:
    void print()
    {
        cout << "current value: " << t << endl;
    }
};

int main()
{
    Test<> t;  // 哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随`<>`来实例化。
    t.print();

    Test<int, 1024> t1;
    t1.print();

    return 0;
}
```

但是不支持函数的默认模板参数，`在C++11中添加了对函数模板默认参数的支持`:

```c++
#include <iostream>
using namespace std;

template <typename T=int>	// C++98/03不支持这种写法, C++11中支持这种写法
void func(T t)
{
    cout << "current value: " << t << endl;
}

int main()
{
    func(100);
    return 0;
}
```

通过上面的例子可以得到如下结论：**当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随`<>`来实例化**。

**另外：函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制**。这样当默认模板参数和模板参数自动推导结合起来时，书写就显得非常灵活了。我们可以指定函数模板中的一部分模板参数使用默认参数，另一部分使用**自动推导**，比如下面的例子：

```c++
#include <iostream>
#include <string>
using namespace std;

template <typename R = int, typename N>
R func(N arg)
{
    return arg;
}

int main()
{
    auto ret1 = func(520);
    cout << "return value-1: " << ret1 << endl;

    auto ret2 = func<double>(52.134);
    cout << "return value-2: " << ret2 << endl;

    auto ret3 = func<int>(52.134);
    cout << "return value-3: " << ret3 << endl;

    auto ret4 = func<char, int>(100);
    cout << "return value-4: " << ret4 << endl;

    return 0;
}
```

测试代码输出的结果为:

```c++
return value-1: 520
return value-2: 52.134
return value-3: 52
return value-4: d  // a是97 ，100就是d
```

根据得到的日志输出，分析一下示例代码中调用的模板函数：

- **auto ret = func(520);**
  - 函数返回值类型使用了默认的模板参数，函数的参数类型是**自动推导**出来的为`int`类型。
- **auto ret1 = func<double>(52.134);**
  - 函数的返回值指定为`double`类型，函数参数类型是**通过实参推导**出来的，为`double`类型
- **auto ret3 = func<int>(52.134);**
  - 函数的返回值指定为`int`类型，函数参数类型是**通过实参推导**出来的，为`double`类型
- **auto ret4 = func<char, int>(100);**
  - 函数的参数为指定为`int`类型，函数返回值指定为`char`类型，不需要推导

当默认模板参数和模板参数自动推导同时使用时（优先级**从高到低**）：

- `如果可以推导出参数类型则使用推导出的类型`
- `如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数`
- `如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。`

看一下下面的例子：

```c++
#include <iostream>
#include <string>
using namespace std;

// 函数模板定义
template <typename T, typename U = char>
void func(T arg1 = 100, U arg2 = 100)
{
    cout << "arg1: " << arg1 << ", arg2: " << arg2 << endl;
}

int main()
{
    // 模板函数调用
    func('a');
    func(97, 'a');
    func('a', 97);
    // func();    //编译报错
    return 0;
}
```

程序输出的结果为:

```c++
arg1: a, arg2: d
arg1: 97, arg2: a
arg1: a, arg2: 97
```

分析一下调用的模板函数`func()`：

- `func('a')`：参数`T`被自动推导为`char`类型，`U`使用的默认模板参数为`char`类型
- `func(97, 'a');`：参数`T`被自动推导为`int`类型，`U`使用推导出的类型为`char`
- `func('a', 97);`：参数`T`被自动推导为`char`类型，`U`使用推导出的类型为`int`
- `func();`：参数T没有指定默认模板类型，并且无法自动推导，编译器会直接报错
  - `模板参数类型的自动推导是根据模板函数调用时指定的实参进行推断的`，没有实参则无法推导
  - 模板参数类型的自动推导不会参考函数模板中指定的默认参数。

# 6、数值类型和字符串之间的转换

在C++11中提供了专门的类型转换函数，程序猿可以非常方便的使用它们进行数值类型和字符串类型之间的转换。

## 6.1 数值转为字符串

使用`to_string()`方法可以非常方便地将各种数值类型转换为字符串类型，这是一个重载函，函数声明位于头文件`<string>`中，函数原型如下：

```c++
// 头文件 <string>
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);
```

关于函数的使用是非常简单的，示例代码如下：

```c++
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string pi = "pi is " + to_string(3.1415926);
    string love = "love is " + to_string(5.20 + 13.14);
    cout << pi << endl;
    cout << love << endl;
    return 0;
}
```

## 6.2 字符串转换为数值

由于C++中的数值类型包括`整形`和`浮点型`，因此针对于不同的类型提供了不同的函数，通过调用这些函数可以将字符串类型转换为对应的数值类型。

```c++
// 定义于头文件 <string>
int       stoi( const std::string& str, std::size_t* pos = 0, int base = 10 );
long      stol( const std::string& str, std::size_t* pos = 0, int base = 10 );
long long stoll( const std::string& str, std::size_t* pos = 0, int base = 10 );

unsigned long      stoul( const std::string& str, std::size_t* pos = 0, int base = 10 );
unsigned long long stoull( const std::string& str, std::size_t* pos = 0, int base = 10 );

float       stof( const std::string& str, std::size_t* pos = 0 );
double      stod( const std::string& str, std::size_t* pos = 0 );
long double stold( const std::string& str, std::size_t* pos = 0 );
```

- `str`：要转换的字符串
- `pos`：传出参数, 记录从哪个字符开始无法继续进行解析, 比如: 123`a`bc, 传出的位置为3
- `base`：若 base 为 0 ，则自动检测数值进制：若前缀为 `0` ，则为八进制，若前缀为 `0x` 或 `0X`，则为十六进制，否则为十进制。

这些函数虽然都有多个参数，但是除去第一个参数外其他都有默认值，一般情况下使用默认值就能满足需求。关于函数的使用也给大家提供了一个例子，示例代码如下：

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str1 = "45";
    string str2 = "3.14159";
    string str3 = "9527 with words";
    string str4 = "words and 2";

    int myint1 = std::stoi(str1);
    float myint2 = std::stof(str2);
    int myint3 = std::stoi(str3);
    // 错误： 'std::invalid_argument'
    // int myint4 = std::stoi(str4);

    cout << "std::stoi(\"" << str1 << "\") is " << myint1 << endl;
    cout << "std::stof(\"" << str2 << "\") is " << myint2 << endl;
    cout << "std::stoi(\"" << str3 << "\") is " << myint3 << endl;
    // cout << "std::stoi(\"" << str4 << "\") is " << myint4 << endl;
}
```

示例代码输入的结果如下：

```c++
std::stoi("45") is 45
std::stof("3.14159") is 3.14159
std::stoi("9527 with words") is 9527
```

从上述测试程序可以得出这样的结论，在C++11提供的这些转换函数将字符串转换为数值的过程中：

- `如果字符串中所有字符都是数值类型，整个字符串会被转换为对应的数值，并通过返回值返回`
- `如果字符串的前半部分字符是数值类型，后半部不是，那么前半部分会被转换为对应的数值，并通过返回值返回`
- `如果字符第一个字符不是数值类型转换失败`

# 7、静态断言 static_assert

## 7.1 断言

**断言（assertion）**是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判断表达式放在语句中，用于排除在设计的逻辑上不应该产生的情况。

比如：一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。 

从一些意义上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。

如果我们要在C++程序中使用断言，需要在程序中包含头文件`<cassert>`或`<assert.h>`，头文件中为我们提供了 ==assert== 宏，用于在运行时进行断言。举例说明：

```c++
#include <iostream>
#include <cassert>
using namespace std;

// 创建一个指定大小的 char 类型数组
char* createArray(int size)
{
    // 通过断言判断数组大小是否大于0
    assert(size > 0);	// 必须大于0, 否则程序中断
    char* array = new char[size];
    return array;
}

int main()
{
    char* buf = createArray(0);
    // 此处使用的是vs提供的安全函数, 也可以使用 strcpy
    strcpy_s(buf, 16, "hello, world!");
    cout << "buf = " << buf << endl;
    delete[]buf;
    return 0;
}
```

在程序的第9行，使用了断言==assert(expression)== ，这是一个宏，它的参数是一个表达式，这个表达式通常返回一个布尔类型的值，并且要求表达式必须为 ==true== 程序才能继续向下执行，否则会直接中断。

- 如果 `createArray`参数大于0，程序在16行正常运行直到结束

- 如果 `createArray`参数小于等于0，程序运行到16行直接退出，会看到如下图的提示信息：

  ![image-20241219111729110](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20241219111729110.png)

## 7.2 静态断言

在上面的例子中我们使用了断言 assert。但 **assert是一个运行时断言，也就是说它只有在程序运行时才能起作用** 。这意味着不运行程序我们将无法得知某些条件是否是成立的。 比如：我们想知道当前是32位还是64位平台，对于这个需求我们应该是在程序运行之前就应该得到结果，如果使用断言显然是无法做到的，对于这种情况我们就需要使用C++11提供的静态断言了。

静态断言`static_assert`，所谓静态就是`在编译时就能够进行检查的断言`，使用时**不需要引用头文件**。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。静态断言使用起来非常简单，它接收两个参数：

- `参数1：断言表达式，这个表达式通常需要返回一个 bool值`
- `参数2：警告信息，它通常就是一段字符串，在违反断言（表达式为false）时提示该信息`

由于基于VS计算的字节大小和理论值有出入，下面程序基于64位Linux进行测试，使用静态断言验证当前操作系统是否是32位：

```c++
// assert.cpp
#include <iostream>                                         
using namespace std;
  
int main()
{
    // 字体原因看起来是一个=, 其实这是两个=
    static_assert(sizeof(long) == 4, "错误, 不是32位平台...");
    cout << "64bit Linux 指针大小: " << sizeof(char*) << endl;
    cout << "64bit Linux long 大小: " << sizeof(long) <<endl;
  
    return 0;
}
```

通过g++编译程序：

```shell
$ g++ assert.cpp -std=c++11
assert.cpp: In function ‘int main()’:
assert.cpp:6:5: error: static assertion failed: 错误, 不是32位平台...
static_assert(sizeof(long) == 4, "错误, 不是32位平台...");
```

由于使用的Linux是64位的，因此在编译阶段静态断言检测条件失败，提示的错误信息就是我们给静态断言指定的第二个参数对应的那个字符串。

如果我们将静态断言的条件判断修改一下：

```c++
static_assert(sizeof(long) == 8, "错误, 不是64位平台...");
```

然后再进行编译:

```shell
$ g++ assert.cpp -std=c++11
```

编译通过，得到可执行程序`a.out`，然后执行这个程序可以看到如下输出：

```shell
$ ./a.out 
64bit Linux 指针大小: 8
64bit Linux long 大小: 8
```

静态断言条件判断为`true`，程序就可以继续向下执行了。

> **注意事项：**
>
> ==由于静态断言的表达式是在编译阶段进行检测，所以在它的表达式中不能出现变量，也就是说这个表达式必须是**常量表达式**==。

# 8、noexcept

## 8.1 异常

异常通常用于处理逻辑上可能发生的错误，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。

### 8.1.1 基本语法

关于异常的基本语法如下：

[![2016314153429533.jpg (577×329)](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/2016314153429533.jpg)](https://subingwen.cn/cpp/noexcept/2016314153429533.jpg)

```c++
int main()
{ 
    try
    {
        throw -1; 
    } 
    catch (int e)
    { 
        cout << "int exception, value: " << e << endl; 
    } 
    cout << "That's ok!" << endl; 
    return 0; 
}

输出:
int exception, value: -1
That's ok!
```

> **==异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。==**

### 8.1.2 异常接口声明

为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，常用的有如下三种书写方式：

1. 显示指定可以抛出的异常类型

   ```c++
   struct MyException
   {
       MyException(string s) :msg(s) {}
       string msg;
   };
   
   double divisionMethod(int a, int b) throw(MyException, int)
   {
       if (b == 0)
       {
           throw MyException("division by zero!!!");
           // throw 100;
       }
       return a / b;
   }
   
   int main()
   {
       try
       {	
           double v = divisionMethod(100, 0);
           cout << "value: " << v << endl;
       }
       catch (int e)
       {
           cout << "catch except: "  << e << endl;
       }
       catch (MyException e)
       {
           cout << "catch except: " << e.msg << endl;
       }
       return 0;
   }
   
   输出：
   catch except: division by zero!!!
   ```

   第7行代码在`divisionMethod`函数后添加了`throw`异常接口声明，其参数表示可以抛出的异常类型，分别为==int== 和==MyException== 类型。

2. 抛出任意异常类型

   ```c++
   struct MyException
   {
       MyException(string s) :msg(s) {}
       string msg;
   };
   
   double divisionMethod(int a, int b)
   {
       if (b == 0)
       {
           throw MyException("division by zero!!!");
           // throw 100;
       }
       return a / b;
   }
   
   输出：
   catch except: division by zero!!!
   ```

   第7行代码在`divisionMethod 没有添加异常接口声明`，表示在该函数中`可以抛出任意类型的异常`。

3. 不抛出任何异常

   ```c++
   struct MyException
   {
       MyException(string s) :msg(s) {}
       string msg;
   };
   
   double divisionMethod(int a, int b) throw()
   {
       if (b == 0)
       {
           cout << "division by zero!!!" << endl;
       }
       return a / b;
   }
   
   运行崩溃
   终端有输出"division by zero!!!" 
   ```

   第7行代码在`divisionMethod` 函数后添加了`throw`异常接口声明，其`参数列表为空`，表示该函数`不允许抛出异常`。

> **==温馨提示：以上程序在VS上的测试结果和在Linux上基于G++的测试结果是不同的，如果违反了规则VS只会给出警告，而G++则会直接终止程序的运行。（PS：VS使用的不是G++编译器）==**

## 8.2 noexcept

上面的例子中，在 `divisionMethod` 函数声明之后，我们定义了一个动态异常声明 `throw(MyException, int)`，该声明指出了`divisionMethod`可能抛出的异常的类型。事实上，**该特性很少被使用，因此在C++11中被弃用了** ，而表示函数不会抛出异常的动态异常声明 `throw() `也被新的 **noexcept** 异常声明所取代。 

**noexcept** 形如其名，表示**其修饰的函数不会抛出异常** 。不过与 `throw()`动态异常声明不同的是，`在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些`。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。

因此对于不会抛出异常的函数我们可以这样写:

```c++
#include <iostream>                                         
using namespace std;

struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) noexcept // 使用noexcept不抛出异常，
{
    if (b == 0)
    {
        cout << "division by zero!!!" << endl;
        return -1;
    }
    return a / b;
}

int main()
{
    try
    {
        double v = divisionMethod(100, 0);
        cout << "value: " << v << endl;
    }
    catch (int e)
    {
        cout << "catch except: " << e << endl;
    }
    catch (MyException e)
    {
        cout << "catch except: " << e.msg << endl;
    }
    return 0;
}

输出：
division by zero!!!
value: -1
```

从语法上讲，`noexcept` 修饰符有两种形式：

1. 简单地在函数声明后加上 noexcept 关键字

2. 可以接受一个常量表达式作为参数，如下所示∶

   ```c++
   double divisionMethod(int a, int b) noexcept(常量表达式);
   ```

   常量表达式的结果会被转换成一个bool类型的值：

   - 值为 true，表示函数不会抛出异常
   - 值为 false，表示有可能抛出异常这里
   - **不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常**。

# 第二篇——易学和易用性

# 1、自动推导类型

在C++11中增加了很多新的特性，比如可以使用auto自动推导变量的类型，还能够结合decltype来表示函数的返回值。使用新的特性可以让我们写出更加简洁，更加现代的代码。

## 1.1 auto

在C++11之前auto和static是对应的，表示变量是自动存储的，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，在C++11中他们赋予了新的含义，使用这个关键字能够像别的语言一样自动推导出变量的实际类型。

### 1.1.1 推导规则

C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，`使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。`使用语法如下：

```c++
auto 变量名 = 变量值;  // 必须初始化
```

根据上述语法，来列举一些简单的例子

```c++
auto x = 3.14;      // x 是浮点型 double
auto y = 520;       // y 是整形 int
auto z = 'a';       // z 是字符型 char
auto nb;            // error，变量必须要初始化
auto double nbl;    // 语法错误, 不能修改数据类型   
```

不仅如此，auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：

- **当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字**
- **当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字**

先来看一组变量带指针和引用并使用auto进行类型推导的例子：

```c++
int temp = 110;
auto *a = &temp;	// int
auto b = &temp;		// int*	
auto &c = temp;		// int	
auto d = temp;	    // int	
```

- 变量`a`的数据类型为 `int*`，因此auto关键字被推导为 `int类型`
- 变量`b`的数据类型为 `int*`，因此auto关键字被推导为 `int*`类型
- 变量`c`的数据类型为 `int&`，因此auto关键字被推导为 `int类型`
- 变量`d`的数据类型为 `int`，因此auto关键字被推导为 `int`类型

在来看一组带const限定的变量，使用auto进行类型推导的例子:

```c++
int tmp = 250;
const auto a1 = tmp;   // auto:int
auto a2 = a1;          // auto:int, 当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字
const auto &a3 = tmp;  // auto:int
auto &a4 = a3;         // auto:const int

auto* pt4 = &a1;       // auto:const int
```

- 变量`a1`的数据类型为 `const int`，因此auto关键字被推导为 `int`类型
- 变量`a2`的数据类型为 `int`，但是a2没有声明为指针或引用因此 const属性被去掉, `auto`被推导为 `int`
- 变量`a3`的数据类型为 `const int&`，a3被声明为引用因此 const属性被保留，auto关键字被推导为 `int`类型
- 变量`a4`的数据类型为 `const int&`，a4被声明为引用因此 const属性被保留，auto关键字被推导为 `const int`类型

### 1.1.2 auto的限制

auto关键字并不是万能的，在以下这些场景中是不能完成类型推导的：

1. **不能作为函数参数使用**。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。

   ```c++
   int func(auto a, auto b)	// error
   {	
       cout << "a: " << a <<", b: " << b << endl;
   }
   ```

2. **不能用于类的非静态成员变量的初始化**

   ```c++
   class Test
   {
       auto v1 = 0;                    // error
       static auto v2 = 0;             // error,类的静态非常量成员不允许在类内部直接初始化
       static const auto v3 = 10;      // ok
   }
   ```

3. **不能使用auto关键字定义数组**

   ```c++
   int func()
   {
       int array[] = {1,2,3,4,5};  // 定义数组
       auto t1 = array;            // ok, t1被推导为 int* 类型
       auto t2[] = array;          // error, auto无法定义数组
       auto t3[] = {1,2,3,4,5};;   // error, auto无法定义数组
   }
   ```

4. **无法使用auto推导出模板参数**

   ```c++
   template <typename T>
   struct Test{}
   
   int func()
   {
       Test<double> t;
       Test<auto> t1 = t;           // error, 无法推导出模板类型
       return 0;
   }
   ```

### 1.1.3 auto的应用

了解了auto的限制之后，我们就可以避开这些场景快乐的编程了，下面列举几个比较常用的场景：

1. `用于STL的容器遍历。`

   在C++11之前，定义了一个STL容器之后，遍历的时候常常会写出这样的代码：

   ```c++
   #include <map>
   int main()
   {
       map<int, string> person;
       map<int, string>::iterator it = person.begin();
       for (; it != person.end(); ++it)
       {
           // do something
       }
       return 0;
   }
   ```

   可以看到在定义迭代器变量 it 的时候代码是很长的，写起来就很麻烦，使用了auto之后，就变得清爽了不少：

   ```c++
   #include <map>
   int main()
   {
       map<int, string> person;
       // 代码简化
       for (auto it = person.begin(); it != person.end(); ++it)
       {
           // do something
       }
       return 0;
   }
   ```

2. `用于泛型编程`，在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，比如下面的代码：

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class T1
   {
   public:
       static int get()
       {
           return 10;
       }
   };
   
   class T2
   {
   public:
       static string get()
       {
           return "hello, world";
       }
   };
   
   template <class A>
   void func(void)
   {
       auto val = A::get();
       cout << "val: " << val << endl;
   }
   
   int main()
   {
       func<T1>();
       func<T2>();
       return 0;
   }
   
   输出：
   val: 10
   val: hello, world
   ```

   在这个例子中定义了泛型函数func，在函数中调用了类A的静态方法 get() ，这个函数的返回值是不能确定的，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下:

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class T1
   {
   public:
       static int get()
       {
           return 0;
       }
   };
   
   class T2
   {
   public:
       static string get()
       {
           return "hello, world";
       }
   };
   
   template <class A, typename B>        // 添加了模板参数 B
   void func(void)
   {
       B val = A::get();
       cout << "val: " << val << endl;
   }
   
   int main()
   {
       func<T1, int>();                  // 手动指定返回值类型 -> int
       func<T2, string>();               // 手动指定返回值类型 -> string
       return 0;
   }
   
   输出：
   val: 0
   val: hello, world
   ```

## 1.2 decltype

在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用C++11提供的decltype关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型，语法格式如下：

```c++
decltype (表达式)
```

**decltype** 是“**declare type**”的缩写，意思是“**声明类型**”。decltype的推导是在**编译期完成**的，它只是用于表达式类型的推导，并不会计算表达式的值。来看一组简单的例子：

```c++
int a = 10;
decltype(a) b = 99;                 // b -> int
decltype(a+3.14) c = 52.13;         // c -> double
decltype(a+b*c) d = 520.1314;       // d -> double
```

### 1.2.1 推导规则

通过上面的例子我们初步感受了一下 decltype 的用法，但不要认为 decltype 就这么简单，在它简单的背后隐藏着很多的细节，下面分三个场景依次讨论一下：

1. **表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的**。

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class Test
   {
   public:
       string text;
       static const int value = 110;
   };
   
   int main()
   {
       int x = 99;
       const int &y = x;            
       decltype(x) a = x;           // int
       decltype(y) b = x;           // const int &
       // 在代码中，decltype(Test::value) 推导出的类型是 const int，而不是 static const int，这是因为 decltype 仅推导类型本身，而不推导变量或成员的存储修饰符（如 static）。
       decltype(Test::value) c = 0; // const int
   
       Test t;
       decltype(t.text) d = "hello, world"; // string
   
       return 0;
   }
   ```

   - 变量`a`被推导为 `int`类型
   - 变量`b`被推导为 `const int &`类型
   - 变量`c`被推导为 `const int`类型
   - 变量`d`被推导为 `string`类型

2. **表达式是函数调用，使用decltype推导出的类型和函数==返回值==一致**。

   ```c++
   class Test{...};
   //函数声明
   int func_int();                 // 返回值为 int
   int& func_int_r();              // 返回值为 int&
   int&& func_int_rr();            // 返回值为 int&&
   
   const int func_cint();          // 返回值为 const int
   const int& func_cint_r();       // 返回值为 const int&
   const int&& func_cint_rr();     // 返回值为 const int&&
   
   const Test func_ctest();        // 返回值为 const Test
   
   //decltype类型推导
   int n = 100;
   decltype(func_int()) a = 0;		   // int
   decltype(func_int_r()) b = n;	   // int&
   decltype(func_int_r()) b = 0;      // 编译错误，因为 func_int_r() 返回的是 int&（左值引用），而 0 是一个右值，不能绑定到 int& 类型的变量上。
   decltype(func_int_rr()) c = 0;	   // int&&
   // func_cint()声明为返回const int。
   // 这里的重点是，即使函数返回类型是const int，decltype在推导时不会保留顶层const（除非与引用结合）。
   // 因此，推导出的类型是int，而不是const int。
   decltype(func_cint())  d = 0;	   // int  注意!!!
   decltype(func_cint_r())  e = n;	   // const int&
   decltype(func_cint_rr()) f = 0;	   // const int&&
   decltype(func_ctest()) g = Test(); // const Test
   ```

   - 变量`a`被推导为 `int`类型
   - 变量`b`被推导为 `int&`类型
   - 变量`c`被推导为 `int&&`类型
   - 变量`d`被推导为 `int`类型
   - 变量`e`被推导为 `const int &`类型
   - 变量`f`被推导为 `const int &&`类型
   - 变量`g`被推导为 `const Test`类型

   函数 func_cint() 返回的是一个**纯右值**（在表达式执行结束后不再存在的数据，也就是临时性的数据），`对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符`，因此推导出的变量d的类型为 int 而不是 const int。

3. **表达式是一个左值，或者被括号`( )`包围，使用 decltype推导出的是表达式类型==的引用==（如果有const、volatile限定符不能忽略）**。

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   
   class Test
   {
   public:
       int num;
   };
   
   int main() {
       const Test obj; // obj 是一个 const Test 对象。        
       // 带有括号的表达式
       // obj.num 是对 Test 类的成员变量 num 的访问。成员变量 num 是一个非 const 的 int。
       decltype(obj.num) a = 0;     // int。
       // obj 是 const Test，而 (obj.num) 是带括号的表达式。括号使得 obj.num 被作为一个表达式看待，而不是直接的标识符
       decltype((obj.num)) b = a;   // const int&
       // 加法表达式
       int n = 0, m = 0;
       decltype(n + m) c = 0;       // int
       decltype(n = n + m) d = n;   // int&
       return 0;
   }
   ```

   - `obj.num` 为类的成员访问表达式，符合场景1，因此 `a `的类型为`int`
   - `obj.num` 带有括号，符合场景3，因此`b` 的类型为 `const int&`。
   - `n+m` 得到一个右值，符合场景1，因此`c`的类型为 `int`
   - `n=n+m` 得到一个左值 n，符合场景3，因此`d`的类型为 `int&`

### 1.2.2 decltype的应用

关于decltype的应用多出现在泛型编程中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：

```c++
#include <list>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    ??? m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst;
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

在程序的第17行出了问题，关于迭代器变量一共有两种类型：`只读（T::const_iterator）`和`读写（T::iterator）`，有了decltype就可以完美的解决这个问题了，当 T 是一个 非 const 容器得到一个 T::iterator，当 T 是一个 const 容器时就会得到一个 `T::const_iterator`。

```c++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

`decltype(T().begin())`这种写法在vs2017/vs2019下测试可用完美运行。

## 1.3 返回类型后置

在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：

```c++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<decltype(x + y), int, double>(x, y);
    auto z = add<decltype(x + y)>(x, y);	// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

关于返回值，从上面的代码可以推断出和表达式 `t+u`的结果类型是一样的，因此可以通过通过decltype进行推导，关于模板函数的参数`t`和`u`可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。

因此如果要想解决这个问题就得直接在 `add` 函数身上做文章，先来看第一种写法：

```c++
template <typename T, typename U>
decltype(t+u) add(T t, U u)
{
    return t + u;
}
```

当我们在编译器中将这几行代码改出来后就直接**报错了**，因此decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。

`在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导`。其语法格式如下:

```c++
// 符号 -> 后边跟随的是函数返回值的类型
auto func(参数1, 参数2, ...) -> decltype(参数表达式)
```

通过对上述返回类型后置语法代码的分析，得到结论：`auto 会追踪 decltype() 推导出的类型`，因此上边的`add()`函数可以做如下的修改：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t+u) 
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<int, double>(x, y);
    auto z = add(x, y);		// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

为了进一步说明这个语法，我们再看一个例子：

```c++
#include <iostream>
using namespace std;

int& test(int &i)
{
    return i;
}

double test(double &d)
{
    d = d + 100;
    return d;
}

template <typename T>
// 返回类型后置语法
auto myFunc(T& t) -> decltype(test(t))
{
    return test(t);
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = myFunc<int>(x);
    auto z = myFunc(x);             // 简化之后的写法
    cout << "z: " << z << endl;

    // auto z = myFunc<double>(y);
    auto z1 = myFunc(y);            // 简化之后的写法
    cout << "z1: " << z1 << endl;
    return 0;
}
```

在这个例子中，通过decltype结合返回值后置语法很容易推导出来 `test(t)`函数可能出现的返回值类型，并将其作用到了函数`myFunc()`上。

```c++
// 输出结果
z: 520
z1: 113.14
```

# 2、基于范围的for循环

在C++98/03中，不同的容器和数组遍历的方式不尽相同，写法不统一，也不够简洁，而C++11基于范围的for循环可以以简洁、统一的方式来遍历容器和数组，用起来也更方便了。

## 2.1 for循环新语法

在介绍新语法之前，先来看一个使用迭代器遍历容器的例子

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (auto it = t.begin(); it != t.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
    
    return 0;
}
```

我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。`在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。`

C++98/03中普通的for循环，语法格式：

```c++
for(表达式 1; 表达式 2; 表达式 3)
{
    // 循环体
}
```

C++11基于范围的for循环，语法格式：

```c++
for (declaration : expression)
{
    // 循环体
}
```

在上面的语法格式中`declaration`表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。`expression`是要遍历的对象，它可以是`表达式`、`容器`、`数组`、`初始化列表`等。

使用基于范围的for循环遍历容器，示例代码如下：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (auto value : t)
    {
        cout << value << " ";
    }
    cout << endl;

    return 0;
}
```

在上面的例子中，**是将容器中遍历的当前元素拷贝到了声明的变量value中，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用**。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    cout << "遍历修改之前的容器: ";
    for (auto &value : t)
    {
        cout << value++ << " ";
    }
    cout << endl << "遍历修改之后的容器: ";

    for (auto &value : t)
    {
        cout << value << " ";
    }
    cout << endl;

    return 0;
}
```

代码输出的结果：

```c++
遍历修改之前的容器: 1 2 3 4 5 6
遍历修改之后的容器: 2 3 4 5 6 7
```

对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用`const`定义保存元素数据的变量，在定义的时候建议使用`const auto &`，这样相对于`const auto`效率要更高一些。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (const auto& value : t)
    {
        cout << value << " ";
    }

    return 0;
}
```

## 2.2 使用细节

### 2.2.1 关系型容器

使用基于范围的for循环有一些需要注意的细节，先来看一下对关系型容器map的遍历：

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    // 基于范围的for循环方式
    for (auto& it : m)
    {
        cout << "id: " << it.first << ", name: " << it.second << endl;
    }

    // 普通的for循环方式
    for (auto it = m.begin(); it != m.end(); ++it)
    {
        cout << "id: " << it->first << ", name: " << it->second << endl;
    }

    return 0;
}
```

在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：

1. **使用普通的for循环方式（基于迭代器）遍历关联性容器， auto自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）**：
   - it->first
   - it->second
2. **使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下**：
   - it.first
   - it.second

### 2.2.2 元素只读

通过对基于范围的for循环语法的介绍可以得知，在for循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，**对应set容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在for循环中auto&会被视为const auto &** 。

```c++
#include <iostream>
#include <set>
using namespace std;

int main(void)
{
    set<int> st{ 1,2,3,4,5,6 };
    for (auto &item : st) 
    {
        cout << item++ << endl;		// error, 不能给常量赋值
    }
    return 0;
}
```

除此之外，`在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。`

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    for (auto& item : m)
    {
        // item.first 是一个常量
        cout << "id: " << item.first++ << ", name: " << item.second << endl;  // error
    }

    return 0;
}
```

### 2.2.3 访问次数

基于范围的for循环遍历的对象可以是一个表达式或者容器/数组等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：

```c++
#include <iostream>
#include <vector>
using namespace std;

vector<int> v{ 1,2,3,4,5,6 };
vector<int>& getRange()
{
    cout << "get vector range..." << endl;
    return v;
}

int main(void)
{
    for (auto val : getRange())
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

输出的结果如下：

```c++
get vector range...
1 2 3 4 5 6
```

从上面的结果中可以看到，不论基于范围的for循环迭代了多少次，函数getRange()只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了

> ==**结论：**==
>
> ==**对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。**==

# 3、指针空值类型——nullptr

在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为`NULL`，避免产生`野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）`。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：

```c++
char *ptr = 0;
char *ptr = NULL;
```

在底层源码中`NULL`这个宏是这样定义的:

```c
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

也就是说如果源码是C++程序`NULL`就是`0`，如果是C程序`NULL`表示`(void*)0`。那么为什么要这样做呢？ 是由于 C++ 中，`void *` 类型无法隐式转换为其他类型的指针，此时使用 `0` 代替 `((void *)0)`，用于解决空指针的问题。这个0（0x0000 0000）表示的就是虚拟地址空间中的0地址，这块地址是只读的。

虚拟地址空间结构图：

[![img](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20210130093015907.png)](https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png)

C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，`NULL` 和 `0` 无法区分：

```c++
#include <iostream>
using namespace std;

void func(char *p)
{
    cout << "void func(char *p)" << endl;
}

void func(int p)
{
    cout << "void func(int p)" << endl;
}

int main()
{
    func(NULL);   // 想要调用重载函数 void func(char *p)
    func(250);    // 想要调用重载函数 void func(int p)

    return 0;
}
```

测试代码打印的结果为：

```c++
void func(int p)
void func(int p)
```

通过打印的结果可以看到，虽然调用`func(NULL);`最终链接到的还是`void func(int p)`和预期是不一样的，其实这个原因前边已经说的很明白了，在C++中`NULL`和`0`是等价的。

出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另起炉灶，引入了一个新的关键字`nullptr`。`nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化`

```c++
int*    ptr1 = nullptr;
char*   ptr2 = nullptr;
double* ptr3 = nullptr;
```

对应上面的代码编译器会分别将 `nullptr` 隐式转换成` int*`、`char*` 以及 `double*` 指针类型。

使用`nullptr`可以很完美的解决上边提到的函数重载问题:

```c++
#include <iostream>
using namespace std;

void func(char *p)
{
    cout << "void func(char *p)" << endl;
}

void func(int p)
{
    cout << "void func(int p)" << endl;
}

int main()
{
    func(nullptr);
    func(250);
    return 0;
}
```

测试代码输出的结果:

```c++
void func(char *p)
void func(int p)
```

通过输出的结果可以看出，**nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型**。**在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮**。

# 4、Lambda表达式

## 4.1 基本用法

lambda表达式是C++11最重要也是最常用的特性之一，这是现代编程语言的一个特点，lambda表达式有如下的一些**优点**：

- 声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。
- 简洁：避免了代码膨胀和功能分散，让开发更加高效。
- 在需要的时间和地点实现功能闭包，使程序更加灵活。

lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式简单归纳如下：

```c++
[capture](params) opt -> ret {body;};
```

其中`capture`是捕获列表，`params`是参数列表，`opt`是函数选项，`ret`是返回值类型，`body`是函数体。

1. 捕获列表[]: 捕获一定范围内的变量

2. 参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。

   ```c++
   auto f = [](){return 1;}	// 没有参数, 参数列表为空
   auto f = []{return 1;}		// 没有参数, 参数列表省略不写
   ```

3. opt 选项， `不需要可以省略`

   - **mutable**: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
   - **exception**: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();

4. 返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。

5. 函数体：函数的实现，这部分**不能省略，但函数体可以为空**。

## 4.2 捕获列表

lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：

- `[] `- 不捕捉任何变量
- `[&] `- 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (`按引用捕获`)
- `[=] `- 捕获外部作用域中所有变量, 并作为副本在函数体内使用(`按值捕获`)
  - `拷贝的副本在匿名函数体内部是只读的`
- `[=, &foo]` - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo
- `[bar]` - 按值捕获 bar 变量, 同时不捕获其他变量
- `[&bar]` - 按引用捕获 bar 变量, 同时不捕获其他变量
- `[this]` - 捕获当前类中的this指针
  - 让lambda表达式拥有和当前类成员函数同样的访问权限
  - 如果已经使用了 & 或者 =, 默认添加此选项

下面通过一个例子，看一下初始化列表的具体用法

```c++
#include <iostream>
#include <functional>
using namespace std;

class Test
{
public:
    void output(int x, int y)
    {
        auto x1 = [] {return m_number; };                      // error,没有捕获外部变量，不能使用类成员 m_number
        auto x2 = [=] {return m_number + x + y; };             // ok
        auto x3 = [&] {return m_number + x + y; };             // ok
        auto x4 = [this] {return m_number; };                  // ok
        auto x5 = [this] {return m_number + x + y; };          // error,捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。
        auto x6 = [this, x, y] {return m_number + x + y; };    // ok
        auto x7 = [this] {return m_number++; };                // ok
    }
    int m_number = 100;
};
```

- `x1`：错误，没有捕获外部变量，不能使用类成员 m_number
- `x2`：正确，以值拷贝的方式捕获所有外部变量
- `x3`：正确，以引用的方式捕获所有外部变量
- `x4`：正确，捕获this指针，可访问对象内部成员
- `x5`：错误，捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。
- `x6`：正确，捕获this指针，x，y
- `x7`：正确，捕获this指针，并且可以修改对象内部变量的值

```c++
int main(void)
{
    int a = 10, b = 20;
    auto f1 = [] {return a; };                        // error,没有捕获外部变量，因此无法访问变量 a
    auto f2 = [&] {return a++; };                     // ok
    auto f3 = [=] {return a; };                       // ok
    auto f4 = [=] {return a++; };                     // error，使用值拷贝的方式捕获外部变量，可读不能写
    auto f5 = [a] {return a + b; };                   // error，使用拷贝的方式捕获了外部变量a，没有捕获外部变量b，因此无法访问变量b
    auto f6 = [a, &b] {return a + (b++); };           // ok
    auto f7 = [=, &b] {return a + (b++); };           // ok

    return 0;
}
```

- `f1`：错误，没有捕获外部变量，因此无法访问变量 a
- `f2`：正确，使用引用的方式捕获外部变量，可读写
- `f3`：正确，使用值拷贝的方式捕获外部变量，可读
- `f4`：错误，使用值拷贝的方式捕获外部变量，可读不能写
- `f5`：错误，使用拷贝的方式捕获了外部变量a，没有捕获外部变量b，因此无法访问变量b
- `f6`：正确，使用拷贝的方式捕获了外部变量a，只读，使用引用的方式捕获外部变量b，可读写
- `f7`：正确，使用值拷贝的方式捕获所有外部变量以及b的引用，b可读写，其他只读

> **==在匿名函数内部，需要通过lambda表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下lambda表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。==**

## 4.3 返回值

很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。

```c++
// 完整的lambda表达式定义
auto f = [](int a) -> int
{
    return a+10;  
};

// 忽略返回值的lambda表达式定义
auto f = [](int a)
{
    return a+10;  
};
```

一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是`labmda表达式不能通过列表初始化自动推导出返回值类型。`

```c++
// ok，可以自动推导出返回值类型
auto f = [](int i)
{
    return i;
}

// error，不能推导出返回值类型
auto f1 = []()
{
    return {1, 2};	// 基于列表初始化推导返回值，错误
```

## 4.4 函数本质

使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用**mutable**选项，`被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。`

```c++
int a = 0;
auto f1 = [=] {return a++; };              // error, 按值捕获外部变量, a是只读的
auto f2 = [=]()mutable {return a++; };     // ok
```

最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:

1. `lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。`
2. `按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。`

mutable选项的作用就在于取消operator()的const属性。

因为lambda表达式在C++中会被看做是一个仿函数，因此`可以使用std::function和std::bind来存储和操作lambda表达式`：

```c++
#include <iostream>
#include <functional>
using namespace std;

int main(void)
{
    // 包装可调用函数
    std::function<int(int)> f1 = [](int a) {return a; };
    // 绑定可调用函数
    std::function<int(int)> f2 = bind([](int a) {return a; }, placeholders::_1);

    // 函数调用
    cout << f1(100) << endl;
    cout << f2(200) << endl;
    return 0;
}
```

**对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针**：

```c++
using func_ptr = int(*)(int);
// 没有捕获任何外部变量的匿名函数
func_ptr f = [](int a)
{
    return a;  
};
// 函数调用
f(1314);
```

# 第三篇——通用性能的提升

# 1、constexpr

### 1.1.1 const

在C++11之前只有`const`关键字，从功能上来说这个关键字有双重语义：`变量只读`，`修饰常量`，举一个简单的例子：

```c++
void func(const int num)
{
    const int count = 24;
    int array[num];            // error，num是一个只读变量，不是常量
    int array1[count];         // ok，count是一个常量

    int a1 = 520;
    int a2 = 250;
    const int& b = a1;
    b = a2;                         // error
    a1 = 1314;
    cout << "b: " << b << endl;     // 输出结果为1314
}
```

- 函数`void func(const int num)`的参数`num`表示这个变量是只读的，但不是常量，因此使用`int array[num]; `这种方式定义一个数组，编译器是会报错的，提示`num不可用作为常量来使用`。
- `const int count = 24;`中的`count`却是一个常量，因此可以使用这个常量来定义一个静态数组。

另外，`变量只读并不等价于常量`，二者是两个概念不能混为一谈，分析一下这句测试代码`const int& b = a1;`：

- `b`是一个常量的引用，所以b引用的变量是不能被修改的，也就是说`b = a2; `这句代码语法是错误的。
- 在`const`对于变量`a1`是没有任何约束的，`a1`的值变了`b`的值也就变了
- 引用`b`是只读的，但是并不能保证它的值是不可改变的，也就是说它不是常量。

### 1.1.2 constexpr

在C++11中添加了一个新的关键字`constexpr`，这个关键字是用来修饰常量表达式的。所谓`常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。`

在介绍gcc/g++工作流程的时候说过，C++ 程序从编写完毕到执行分为四个阶段：`预处理`、 `编译`、`汇编`和`链接`4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，`常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率`，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。

那么问题来了，编译器如何识别表达式是不是常量表达式呢？在C++11中添加了`constexpr`关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 `const` 和 `constexpr` 的功能区分开，即`凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。`

在定义常量时，`const` 和 `constexpr` 是等价的，都可以在程序的编译阶段计算出结果，例如：

```c++
const int m = f();  // 不是常量表达式，m的值只有在运行时才会获取。
const int i=520;    // 是一个常量表达式
const int j=i+1;    // 是一个常量表达式

constexpr int i=520;    // 是一个常量表达式
constexpr int j=i+1;    // 是一个常量表达式
```

对于 C++ 内置类型的数据，可以直接用 `constexpr` 修饰，但如果是自定义的数据类型（用 `struct` 或者 `class` 实现），直接用 `constexpr` 修饰是不行的。

```c++
// 此处的constexpr修饰是无效的
constexpr struct Test
{
    int id;
    int num;
};
```

如果要定义一个结构体/类常量对象，可以这样写：

```c++
struct Test
{
    int id;
    int num;
};

int main()
{
    constexpr Test t{ 1, 2 };
    constexpr int id = t.id;
    constexpr int num = t.num;
    // error，不能修改常量
    t.num += 100;
    cout << "id: " << id << ", num: " << num << endl;

    return 0;
}
```

在第13行的代码中`t.num += 100;`的操作是错误的，对象`t`是一个常量，因此它的成员也是常量，常量是不能被修改的。

## 1.2 常量表达式函数

为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用`constexpr`修饰函数的返回值，这种函数被称作`常量表达式函数`，这些函数主要包括以下几种：`普通函数/类成员函数`、`类的构造函数`、`模板函数`。

### 1.2.1 修饰函数

> **==温馨提示：由于现在编译器版本都比较高，默认的使用的C++标准也比较高（大于C++11），相关源代码请基于 C++11 标准进行测试。==**

`constexpr`并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：

1. 函数必须要有返回值，并且return 返回的表达式必须是常量表达式。

   ```c++
   // error，不是常量表达式函数
   constexpr void func1()
   {
       int a = 100;
       cout << "a: " << a << endl;
   }
   
   // error，不是常量表达式函数
   constexpr int func1()
   {
       int a = 100;
       return a;
   }
   ```

   - 函数`func1()`没有返回值，不满足常量表达式函数要求

   - 函数`func2()`返回值不是常量表达式，不满足常量表达式函数要求

     [![image-20230513082727668](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20230513082727668.png)](https://subingwen.cn/cpp/constexpr/image-20230513082727668.png)

   由此可见在`更新的C++标准`里边放宽了对`constexpr`的语法限制。

2. 函数在使用之前，必须有对应的定义语句。**函数的声明跟实现都要在函数的使用前面**

   ```c++
   #include <iostream>
   using namespace std;
   
   constexpr int func1();
   int main()
   {
       constexpr int num = func1();	// error
       return 0;
   }
   
   constexpr int func1()
   {
       constexpr int a = 100;
       return a;
   }
   ```

   在测试程序`constexpr int num = func1();`中，还没有定义`func1()`就直接调用了，应该将`func1()`函数的定义放到`main()`函数的上边。

3. 整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return语句除外）。

   ```c++
   // error
   constexpr int func1()
   {
       constexpr int a = 100;
       constexpr int b = 10;
       for (int i = 0; i < b; ++i)
       {
           cout << "i: " << i << endl;
       }
       return a + b;
   }
   
   // ok
   constexpr int func2()
   {
       using mytype = int;
       constexpr mytype a = 100;
       constexpr mytype b = 10;
       constexpr mytype c = a * b;
       return c - (a + b);
   }
   ```

   因为`func1()`是一个常量表达式函数，在函数体内部是**不允许出现非常量表达式以外的操作**，因此函数体内部的`for`循环是一个非法操作。

> 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：

```c++
class Test
{
public:
    constexpr int func()
    {
        constexpr int var = 100;
        return 5 * var;
    }
};

int main()
{
    Test t;
    constexpr int num = t.func();
    cout << "num: " << num << endl;

    return 0;
}
```

### 1.2.2 修饰模板函数

C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。`如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。`

```c++
#include <iostream>
using namespace std;

struct Person {
    const char* name;
    int age;
};

// 定义函数模板
template<typename T>
constexpr T display(T t) {
    return t;
}

int main()
{
    struct Person p { "luffy", 19 };
    //普通函数
    struct Person ret = display(p);
    cout << "luffy's name: " << ret.name << ", age: " << ret.age << endl;

    //常量表达式函数
    constexpr int ret1 = display(250);
    cout << ret1 << endl;

    constexpr struct Person p1 { "luffy", 19 };
    constexpr struct Person p2 = dispaly(p1);
    cout << "luffy's name: " << p2.name << ", age: " << p2.age << endl;
    return 0;
}
```

在上面示例程序中定义了一个函数模板 `display()`，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：

- `struct Person ret = display(p);`由于参数`p`是变量，所以实例化后的函数不是常量表达式函数，此时 `constexpr` 是无效的
- `constexpr int ret1 = display(250);`参数是常量，符合常量表达式函数的要求，此时 `constexpr` 是有效的
- `constexpr struct Person p2 = display(p1);`参数是常量，符合常量表达式函数的要求，此时 `constexpr` 是有效的

### 1.2.3 修饰构造函数

如果想用直接得到一个常量对象，也可以使用`constexpr`修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：`构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。`

```c++
#include <iostream>
using namespace std;

struct Person {
    constexpr Person(const char* p, int age) :name(p), age(age)
    {
    }
    const char* name;
    int age;
};

int main()
{
    constexpr struct Person p1("luffy", 19);
    cout << "luffy's name: " << p1.name << ", age: " << p1.age << endl;
    return 0;
}
```

# 2、委托构造和集成构造函数

## 2.1 委托构造函数

委托构造函数**允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化**。下面举例说明：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min)
    {
        this->m_max = max > 0 ? max : 100;              // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;   
    }

    Test(int max, int min, int mid)
    {
        this->m_max = max > 0 ? max : 100;             // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;  // 冗余代码
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};

int main()
{
    Test t(90, 30, 60);
    cout << "min: " << t.m_min << ", middle: " 
         << t.m_middle << ", max: " << t.m_max << endl;
    return 0;
}
```

在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min):Test(max)
    {
        this->m_min = min > 0 && min < max ? min : 1;
    }

    Test(int max, int min, int mid):Test(max, min)
    {
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};

int main()
{
    Test t(90, 30, 60);
    cout << "min: " << t.m_min << ", middle: " 
         << t.m_middle << ", max: " << t.m_max << endl;
    return 0;
}
```

在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：

- **这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。**

- **如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。**

  ```c++
  Test(int max)
  {
      this->m_max = max > 0 ? max : 100;
  }
  
  Test(int max, int min)
  {
      Test(max);	// error, 此处编译器会报错, 提示形参max被重复定义
      this->m_min = min > 0 && min < max ? min : 1;
  }
  ```

- **在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了**。

  ```c++
  // 错误, 使用了委托构造函数就不能再次m_max初始化了
  Test(int max, int min) : Test(max), m_max(max)
  {
      this->m_min = min > 0 && min < max ? min : 1;
  }
  ```

## 2.2 继承构造函数

C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    Child(int i) :Base(i) {}
    Child(int i, double j) :Base(i, j) {}
    Child(int i, double j, string k) :Base(i, j, k) {}
};

int main()
{
    Child c(520, 13.14, "i love you");
    cout << "int: " << c.m_i << ", double: " 
         << c.m_j << ", string: " << c.m_k << endl;
    return 0;
}
```

通过测试代码可以看出，在子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数，这是非常繁琐的，C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。

继承构造函数的使用方法是这样的：通过使用`using 类名::构造函数名`（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;  // 可以在子类使用父类所有的构造函数
};

int main()
{
    Child c1(520, 13.14);
    cout << "int: " << c1.m_i << ", double: " << c1.m_j << endl;
    Child c2(520, 13.14, "i love you");
    cout << "int: " << c2.m_i << ", double: " 
         << c2.m_j << ", string: " << c2.m_k << endl;
    return 0;
}
```

在修改之后的子类中，没有添加任何构造函数，而是添加了`using Base::Base;`这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。

另外如果在子类中隐藏了父类中的同名函数，也可以通过`using`的方式在子类中使用基类中的这些父类函数：

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    void func(int i)
    {
        cout << "base class: i = " << i << endl;
    }
    
    void func(int i, string str)
    {
        cout << "base class: i = " << i << ", str = " << str << endl;
    }

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;   // 继承父类的构造函数
    using Base::func;   // 当子类有跟父类同名的函数时，父类的同名函数会被隐藏，添加这句代码之后，子类才可以调用父类被隐藏的同名函数
    void func()
    {
        cout << "child class: i'am luffy!!!" << endl;
    }
};

int main()
{
    Child c(250);
    c.func();
    c.func(19);
    c.func(19, "luffy");
    return 0;
}
```

上述示例代码输出的结果为：

```c++
child class: i'am luffy!!!
base class: i = 19
base class: i = 19, str = luffy
```

子类中的`func()`函数隐藏了基类中的两个`func()`因此默认情况下通过子类对象只能调用无参的`func()`，在上面的子类代码中添加了`using Base::func;`之后，就可以通过子类对象直接调用父类中被隐藏的带参`func()`函数了。

# 3、右值引用

## 3.1 右值引用

### 3.1.1 右值

C++11 增加了一个新的类型，称为**右值引用**（ R-value reference），标记为` &&`。在介绍右值引用类型之前先要了解什么是左值和右值：

- lvalue 是`locator value`的缩写，rvalue 是 `read value`的缩写;
- **左值**是指存储在内存中、有明确存储地址（可取地址）的数据；
- **右值**是指可以提供数据值的数据（不可取地址）；

通过描述可以看出，区分左值与右值的便捷方法是：**可以对表达式取地址（&）就是左值**，否则为右值 。**所有有名字的变量或对象都是左值**，而**右值是匿名的**。

```c++
int a = 520;
int b = 1314;
a = b;
```

**一般情况下，位于`=`前的表达式为左值，位于`=`后边的表达式为右值**。也就是说例子中的`a, b`为左值，`520,1314`为右值。`a=b`是一种特殊情况，在这个表达式中`a, b`都是左值，因为变量`b`是可以被取地址的，不能视为右值。

C++11 中右值可以分为两种：一个是**将亡值**（ xvalue, expiring value），另一个则是**纯右值**（ prvalue, PureRvalue）：

- `纯右值`：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等
- `将亡值`：与右值引用相关的表达式，比如，T&&类型函数的返回值、 std::move 的返回值等。

```c++
int value = 520;
```

在上面的语句中，value是左值，520是字面量也就是右值。其中value可以被引用，但是520就不行了，因为字面量都是右值。

### 3.1.2 右值引用

右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。`无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”`，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

关于右值引用的使用，参考代码如下：

```c++
#include <iostream>
using namespace std;

int&& value = 520;
class Test
{
public:
    Test()
    {
        cout << "construct: my name is jerry" << endl;
    }
    Test(const Test& a)
    {
        cout << "copy construct: my name is tom" << endl;
    }
};

// 该函数返回一个临时的 Test 对象（右值），通过 return Test(); 创建并返回一个 Test 类型的临时对象
Test getObj()
{
    return Test();
}

int main()
{
    int a1;
    int &&a2 = a1;        // error,a1是左值，不能右值引用
    Test& t = getObj();   // error，右值不能给普通的左值引用赋值。
    Test && t = getObj();
    // 常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。
    const Test& t = getObj();
    
    return 0;
}
```

- 在上面的例子中`int&& value = 520;`里面`520`是纯右值，`value`是对字面量`520`这个右值的引用。
- 在`int &&a2 = a1;`中`a1`虽然写在了`=`右边，但是它仍然是一个左值，`使用左值初始化一个右值引用类型是不合法的。`
- 在`Test& t = getObj()`这句代码中语法是错误的，`右值不能给普通的左值引用赋值。`
- 在`Test && t = getObj();`中`getObj()`返回的`临时对象`被称之为`将亡值`，`t`是这个将亡值的右值引用。
- `const Test& t = getObj()`这句代码的语法是正确的，`常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。`

## 3.2 性能优化

在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以**使用右值引用进行性能的优化**。

再来修改一下上面的实例代码：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() : m_num(new int(100))  // 构造函数
    {
        cout << "construct: my name is jerry" << endl;
    }

    Test(const Test& a) : m_num(new int(*a.m_num))  // 拷贝构造函数
    {
        cout << "copy construct: my name is tom" << endl;
    }

    ~Test()  // 析构函数
    {
        delete m_num;  // 释放分配的内存
    }

    int* m_num;  // 指针成员
};

Test getObj()
{
    Test t;  // 创建局部变量 t
    return t;  // 返回 t，触发拷贝构造或移动构造
}

int main()
{
    Test t = getObj();  // 返回值会触发拷贝或移动构造
    cout << "t.m_num: " << *t.m_num << endl;  // 输出 t.m_num 的值
    return 0;
}
```

测试代码执行的结果为（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）:

```c++
construct: my name is jerry
copy construct: my name is tom
t.m_num: 100
```

通过输出的结果可以看到调用`Test t = getObj();`的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到了对象`t`，在`getObj()`函数中创建的对象虽然进行了内存的申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省资源申请和释放的时间，如果要执行这样的操作就需要使用右值引用了，右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() : m_num(new int(100))
    {
        cout << "construct: my name is jerry" << endl;
    }

    Test(const Test& a) : m_num(new int(*a.m_num))
    {
        cout << "copy construct: my name is tom" << endl;
    }

    // 添加移动构造函数 -> 复用其他对象中的资源（堆内存）
    Test(Test&& a) : m_num(a.m_num)
    {
        a.m_num = nullptr;    // 使原对象的指针失效
        cout << "move construct: my name is sunny" << endl;
    }

    ~Test()
    {
        delete m_num;
        cout << "destruct Test class ..." << endl;
    }

    int* m_num;
};

Test getObj()
{
    Test t;
    return t;
}

int main()
{
    // 要求右侧对象是一个临时对象，才会调用移动构造函数
    // 如果没有移动构造函数，就会调用拷贝构造函数
    Test t = getObj();
    cout << "t.m_num: " << *t.m_num << endl;
    return 0;
};
```

测试代码执行的结果如下（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）:

```c++
construct: my name is jerry
move construct: my name is sunny
destruct Test class ...
t.m_num: 100
destruct Test class ...
```

通过修改，在上面的代码给`Test`类添加了`移动构造函数（参数为右值引用类型）`，这样在进行`Test t = getObj();`操作的时候并没有调用拷贝构造函数进行深拷贝，而是调用了移动构造函数，在这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高了性能。

在测试程序中`getObj()`的返回值就是一个将亡值，也就是说是一个右值，在进行赋值操作的时候如果`=`右边是一个右值，那么移动构造函数就会被调用。`移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。`

> **==对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。==**

## 3.3 && 的特性

在C++中，并不是所有情况下 && 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为`T&&`，如果是自动类型推导需要指定为`auto &&`，在这两种场景下 &&被称作**未定的引用类型**。另外还有一点需要额外注意`const T&&`表示一个右值引用，不是未定引用类型。

先来看第一个例子，在函数模板中使用&&:

```c++
template<typename T>
void f(T&& param);
void f1(const T&& param);
f(10); 	
int x = 10;
f(x); 
f1(x);	// error, x是左值
f1(10); // ok, 10是右值
```

在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。

- 第4行中，对于`f(10)`来说传入的实参10是右值，因此`T&&`表示右值引用
- 第6行中，对于`f(x)`来说传入的实参是x是左值，因此`T&&`表示左值引用
- 第7行中，`f1(x)`的参数是`const T&&`不是未定引用类型，不需要推导，本身就表示一个右值引用

再来看第二个例子:

```c++
int main()
{
    int x = 520, y = 1314;
    auto&& v1 = x;
    auto&& v2 = 250;
    decltype(x)&& v3 = y;   // error
    cout << "v1: " << v1 << ", v2: " << v2 << endl;
    return 0;
};
```

- 第4行中 `auto&&`表示一个整形的左值引用
- 第5行中 `auto&&`表示一个整形的右值引用
- 第6行中`decltype(x)&&`等价于`int&&`是一个右值引用不是未定引用类型，y是一个左值，`不能使用左值初始化一个右值引用类型。`

由于上述代码中存在`T&&`或者`auto&&`这种未定引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型（&&）会发生变化，这种变化被称为引用折叠。在C++11中引用折叠的**==规则==**如下：

- ==**通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型**==
- ==**通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&& 或者 auto&& 得到的是一个左值引用类型**==

```c++
int&& a1 = 5;
auto&& bb = a1;
auto&& bb1 = 5;

int a2 = 5;
int &a3 = a2;
auto&& cc = a3;
auto&& cc1 = a2;

const int& s1 = 100;
const int&& s2 = 100;
auto&& dd = s1;
auto&& ee = s2;

const auto&& x = 5;
```

- 第2行：`a1`为右值引用，推导出的`bb`为`左值引用`类型
- 第3行：`5`为右值，推导出的`bb1`为`右值引用`类型
- 第7行：`a3`为左值引用，推导出的`cc`为`左值引用`类型
- 第8行：`a2`为左值，推导出的`cc1`为`左值引用`类型
- 第12行：`s1`为常量左值引用，推导出的`dd`为`常量左值引用`类型
- 第13行：`s2`为常量右值引用，推导出的`ee`为`常量左值引用`类型
- 第15行：`x`为右值引用，不需要推导，只能通过右值初始化

再看最后一个例子，代码如下：

```c++
#include <iostream>
using namespace std;

void printValue(int &i)
{
    cout << "l-value: " << i << endl;
}

void printValue(int &&i)
{
    cout << "r-value: " << i << endl;
}

void forward(int &&k)
{
    printValue(k);
}

int main()
{
    int i = 520;
    printValue(i);
    printValue(1314);
    forward(250);

    return 0;
};
```

测试代码输出的结果如下:

```c++
l-value: 520
r-value: 1314
l-value: 250
```

根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数forward()接收的是一个右值，但是在这个函数中调用函数printValue()时，参数k变成了一个命名对象，编译器会将其当做左值来处理。

最后总结一下关于&&的使用：

1. `左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。`
2. `编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。`
3. `auto&&或者函数参数类型自动推导的T&&是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。`
4. `通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型，其余都是左值引用类型。`

# 4、转移和完美转发

## 4.1 move

在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，`使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。`

从实现上讲，std::move基本等同于一个类型转换：`static_cast<T&&>(lvalue);`，函数原型如下:

```c++
template<class _Ty>
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) _NOEXCEPT
{	// forward _Arg as movable
    return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
}
```

使用方法如下：

```c++
class Test
{
public：
    Test(){}
    ......
}
int main()
{
    Test t;
    Test && v1 = t;          // error
    Test && v2 = move(t);    // ok
    return 0;
}
```

- 在第10行中，使用左值初始化右值引用，因此语法是错误的
- 在第11行中，使用`move()`函数将左值转换为了右值，这样就可以初始化右值引用了。

假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：

```c++
list<string> ls;
ls.push_back("hello");
ls.push_back("world");
......
list<string> ls1 = ls;        // 需要拷贝, 效率低
list<string> ls2 = move(ls);
```

如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（`T::T(T&& another)`）和和具有移动语义的赋值函数（`T&& T::operator=(T&& rhs)`），在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。

## 4.2 forward

右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用C++11提供的std::forward()函数，该函数实现的功能称之为**完美转发**。

```c++
// 函数原型
template <class T> T&& forward (typename remove_reference<T>::type& t) noexcept;
template <class T> T&& forward (typename remove_reference<T>::type&& t) noexcept;

// 精简之后的样子
std::forward<T>(t);
```

- `当T为左值引用类型时，t将被转换为T类型的左值`
- `当T不是左值引用类型时，t将被转换为T类型的右值`

下面通过一个例子演示一下关于forward的使用:

```c++
#include <iostream>
using namespace std;

// 这个函数模板接受一个左值引用（T&）。它会打印出一个左值，即传入的是一个命名的对象。
template<typename T>
void printValue(T& t)
{
    cout << "l-value: " << t << endl;
}

// 这个函数模板接受一个右值引用（T&&）。它会打印出一个右值，即传入的是临时对象或通过 move 转换的对象。
template<typename T>
void printValue(T&& t)
{
    cout << "r-value: " << t << endl;
}

template<typename T>
void testForward(T&& v)
{
    printValue(v);               // 传递原始参数 v
    printValue(move(v));         // 传递 v 的右值引用，强制转换为右值
    printValue(forward<T>(v));   // 完美转发 v，保持原有的值类别（左值或右值）
    cout << endl;
}

int main()
{
    testForward(520);                // 传入右值
    int num = 1314;
    testForward(num);                // 传入左值
    testForward(forward<int>(num));  // 完美转发 num，传入左值
    testForward(forward<int&>(num)); // 完美转发 num 的左值引用
    testForward(forward<int&&>(num));// 完美转发 num 的右值引用

    return 0;
}
```

测试代码打印的结果如下:

```c++
l-value: 520
r-value: 520
r-value: 520

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314
```

- `testForward(520);`函数的形参为**未定引用类型**`T&&`，实参为右值，初始化后被推导为一个右值引用
  - `printValue(v);`已命名的右值v，编译器会视为左值处理，实参为`左值`
  - `printValue(move(v));`已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为右值引用，最终得到一个右值，实参为``右值`
- `testForward(num);`函数的形参为**未定引用类型**`T&&`，实参为左值，初始化后被推导为一个左值引用
  - `printValue(v);`实参为`左值`
  - `printValue(move(v));`通过move将左值转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为左值引用，最终得到一个左值引用，实参为`左值`
- `testForward(forward<int>(num));` forward的模板类型为int，最终会得到一个右值，函数的形参为**未定引用类型**`T&&`被右值初始化后得到一个右值引用类型
  - `printValue(v);`已命名的右值v，编译器会视为左值处理，实参为`左值`
  - `printValue(move(v));`已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为右值引用，最终得到一个右值，实参为`右值`
- `testForward(forward<int&>(num));`forward的模板类型为int&，最终会得到一个左值，函数的形参为未定引用类型`T&&`被左值初始化后得到一个左值引用类型
  - `printValue(v);`实参为`左值`
  - `printValue(move(v));`通过move将左值转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为左值引用，最终得到一个左值，实参为`左值`
- `testForward(forward<int&&>(num));`forward的模板类型为int&&，最终会得到一个右值，函数的形参为未定引用类`T&&`被右值初始化后得到一个右值引用类型
  - `printValue(v);`已命名的右值v，编译器会视为左值处理，实参为`左值`
  - `printValue(move(v));`已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为右值引用，最终得到一个右值，实参为`右值`

# 5、列表初始化

关于C++中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在C++11中提出了**列表初始化**的概念。

## 5.1 统一的初始化

在C++98/03中，对应普通数组和可以直接进行内存拷贝（memcpy()）的对象是可以使用列表初始化来初始化数据的

```c++
// 数组的初始化
int array[] = { 1,3,5,7,9 };
double array1[3] = { 1.2, 1.3, 1.4 };

// 对象的初始化
struct Person
{
    int id;
    double salary;
}zhang3{ 1, 3000 };
```

在C++11中，列表初始化变得更加灵活了，来看一下下面这段初始化类对象的代码：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test(int) {}
private:
    Test(const Test &);
};

int main(void)
{
    Test t1(520);
    Test t2 = 520;             // 错误
    Test t3 = { 520 };
    Test t4{ 520 };
    int a1 = { 1314 };
    int a2{ 1314 };
    int arr1[] = { 1, 2, 3 };
    int arr2[]{ 1, 2, 3 };
    return 0;
}
```

具体地来解读一下上面代码中使用的各种初始化方式：

- `t1`：最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化

- `t2`：语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，`520`会通过隐式类型转换被`Test(int)`构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到`t2`（**这个错误在VS中不会出现，在Linux中使用g++编译会提示描述的这个错误**，截图如下。）

  [![image-20210519095041852](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20210519095041852.png)](https://subingwen.cn/cpp/list-init/image-20210519095041852.png)

- `t3`和`t4`：使用了C++11的初始化方式来初始化对象，效果和`t1`的方式是相同的。
  - 在初始时，{}前面的等号是否书写对初始化行为没有任何影响。
  - `t3`虽然使`用了等号，但是它仍然是列表初始化`，因此私有的拷贝构造对它没有任何影响。
- `t1、arr1`和`t2、arr2`：这两个是基础数据类型的列表初始化方式，可以看到，和对象的初始化方式是统一的。
- `t4`、`a2`、`arr2`的写法，是C++11中新添加的语法格式，`使用这种方式可以直接在变量名后边跟上初始化列表，来进行变量或者对象的初始化。`

既然使用列表初始化可以对普通类型以及对象进行直接初始化，那么在使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化吗？答案是肯定的，来看下面的例子：

```c++
int * p = new int{520};
double b = double{52.134};
int * array = new int[3]{1,2,3};
```

- `指针p`指向了一个new操作符返回的内存，通过列表初始化将内存数据初始化为了520
- `变量b`是对匿名对象使用列表初始之后，再进行拷贝初始化。
- `数组array`在堆上动态分配了一块内存，通过列表初始化的方式直接完成了多个元素的初始化。

除此之外，列表初始化还可以直接用在函数返回值上：

```c++
#include <iostream>
#include <string>
using namespace std;

class Person
{
public:
    Person(int id, string name)
    {
        cout << "id: " << id << ", name: " << name << endl;
    }
};

Person func()
{
    return { 9527, "华安" };
}

int main(void)
{
    Person p = func();
    return 0;
}
```

代码中的`return { 9527, "华安" };`就相当于`return (9527, "华安" );`，直接返回了一个匿名对象。通过上面的几个例子可以看出在C++11使用列表初始化是非常便利的，它统一了各种对象的初始化方式，而且还让代码的书写更加简单清晰。

## 5.2 列表初始化细节

### 5.2.1 聚合体

在C++11中，列表初始化的使用范围被大大增强了，但是一些模糊的概念也随之而来，在前面的例子可以得知，列表初始化可以用于自定义类型的初始化，但是对于一个自定义类型，列表初始化可能有两种执行结果：

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    int y;
}a = { 123, 321 };

struct T2
{
    int x;
    int y;
    T2(int, int) : x(10), y(20) {}
}b = { 123, 321 };

int main(void)
{
    cout << "a.x: " << a.x << ", a.y: " << a.y << endl;
    cout << "b.x: " << b.x << ", b.y: " << b.y << endl;
    return 0;
}
```

程序执行的结果是这样的:

```c++
a.x: 123, a.y: 321
b.x: 10, b.y: 20
```

在上边的程序中都是用列表初始化的方式对对象进行了初始化，但是得到结果却不同，对象b并没有被初始化列表中的数据初始化，这是为什么呢？

- **对象a是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的成员。**
- **在结构体T2中自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的。**

现在很多小伙伴可能就一头雾水了，同样是自定义结构体并且在创建对象的时候都使用了列表初始化来初始化对象，为什么在类内部对对象的初始化方式却不一样呢？`因为如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是初始化列表中的数据就会拷贝到对象中。`

那么，使用列表初始化时，对于什么样的类型C++会认为它是一个**聚合体**呢？

- **普通数组本身可以看做是一个聚合类型**

  ```c++
  int x[] = {1,2,3,4,5,6};
  double y[3][3] = {
      {1.23, 2.34, 3.45},
      {4.56, 5.67, 6.78},
      {7.89, 8.91, 9.99},
  };
  char carry[] = {'a', 'b', 'c', 'd', 'e', 'f'};
  std::string sarry[] = {"hello", "world", "nihao", "shijie"};
  ```

- 满足以下条件的类（class、struct、union）可以被看做是一个**聚合类型**：

  - **无用户自定义的构造函数**。

  - **无私有或保护的非静态数据成员**。

    - 场景1: 类中有私有成员, 无法使用列表初始化进行初始化

      ```c++
      struct T1
      {
          int x;
          long y;
      protected:
          int z;
      }t{ 1, 100, 2};		// error, 类中有私有成员, 无法使用初始化列表初始化
      ```

    - 场景2：类中有非静态成员可以通过列表初始化进行初始化，但它不能初始化静态成员变量。

      ```c++
      struct T2
      {
          int x;
          long y;
      protected:
          static int z;
      }t{ 1, 100， 2};		// error
      ```

      结构体中的静态变量 z 不能使用列表初始化进行初始化，它的初始化遵循静态成员的初始化方式。

      ```c++
      struct T2
      {
          int x;
          long y;
      protected:
          static int z;
      }t{ 1, 100};		// ok
      // 静态成员的初始化
      int T2::z = 2;
      ```

  - 无基类。

  - 无虚函数。

  - 类中不能有使用`{}`和`=`直接初始化的非静态数据成员（从c++14开始就支持了）。

    ```c++
    #include <iostream>
    #include <string>
    using namespace std;
    
    struct T2
    {
        int x;
        long y;
    protected:
        static int z;
    }t1{ 1, 100 };		// ok
    // 静态成员的初始化
    int T2::z = 2;
    
    struct T3
    {
        int x;
        double y = 1.34;
        int z[3]{1,2,3};
    };
    
    int main(void)
    {
        T3 t{520, 13.14, {6,7,8}};		// error, c++11不支持,从c++14开始就支持了
        return 0;
    }
    ```

    > `从C++14开始，使用列表初始化也可以初始化在类中使用{}和=初始化过的非静态数据成员。`

### 5.2.2 非聚合体

对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，`需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:`

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    double y;
    // 在构造函数中使用初始化列表初始化类成员
    T1(int a, double b, int c) : x(a), y(b), z(c){}
    virtual void print()
    {
        cout << "x: " << x << ", y: " << y << ", z: " << z << endl;
    }
private:
    int z;
};

int main(void)
{
    T1 t{ 520, 13.14, 1314 };	// ok, 基于构造函数使用初始化列表初始化类成员
    t.print();
    return 0;
}
```

另外，需要额外注意的是`聚合类型的定义并非递归的`，也就是说`当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型`，比如下面的这个例子：

```c++
#include <iostream>
#include <string>
using namespace std;

// 非聚合体
struct T1
{
    int x;
    double y;
private:
    int z;
};

// 聚合体
struct T2
{
    T1 t1;
    long x1;
    double y1;
};

int main(void)
{
    T2 t2{ {}, 520, 13.14 };
    return 0;
}
```

可以看到，T1并非一个聚合类型，因为它有一个Private的非静态成员。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。

最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号`{}`，这相当于调用是T1的无参构造函数。

> **==对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数。==**

## 5.3 std::initializer_list

在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用`std::initializer_list`这个轻量级的类模板来实现。

先来介绍一下这个类模板的一些特点：

- 它是一个轻量级的容器类型，内部定义了迭代器`iterator`等容器必须的概念，`遍历时得到的迭代器是只读的。`
- 对于`std::initializer_list<T>`而言，它可以接收任意长度的初始化列表，但是要求**元素必须是同种类型T**
- 在`std::initializer_list`内部有三个成员接口：`size()`, `begin()`, `end()`。
- `std::initializer_list`对象只能被整体初始化或者赋值。

### 5.3.1 作为普通函数参数

如果想要自定义一个函数并且接收任意个数的参数（变参函数），只需要将函数参数指定为`std::initializer_list`，使用初始化列表`{ }`作为实参进行数据传递即可。

```c++
#include <iostream>
#include <string>
using namespace std;

void traversal(std::initializer_list<int> a)
{
    for (auto it = a.begin(); it != a.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main(void)
{
    initializer_list<int> list;
    cout << "current list size: " << list.size() << endl;
    traversal(list);

    list = { 1,2,3,4,5,6,7,8,9,0 };
    cout << "current list size: " << list.size() << endl;
    traversal(list);
    cout << endl;
    
    list = { 1,3,5,7,9 };
    cout << "current list size: " << list.size() << endl;
    traversal(list);
    cout << endl;

    ////////////////////////////////////////////////////
    ////////////// 直接通过初始化列表传递数据 //////////////
    ////////////////////////////////////////////////////
    traversal({ 2, 4, 6, 8, 0 });
    cout << endl;

    traversal({ 11,12,13,14,15,16 });
    cout << endl;


    return 0;
}
```

示例代码输出的结果：

```c++
current list size: 0

current list size: 10
1 2 3 4 5 6 7 8 9 0

current list size: 5
1 3 5 7 9

2 4 6 8 0

11 12 13 14 15 16
```

std::initializer_list拥有一个无参构造函数`，因此，它可以直接定义实例，此时将`得到一个空的std::initializer_list`，因为在遍历这种类型的容器的时候得到的是一个只读的迭代器，因此我们不能修改里边的数据，只能通过值覆盖的方式进行容器内部数据的修改。虽然如此，在效率方面也无需担心，`std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。

### 5.3.2 作为构造函数参数

自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为`std::initializer_list`类型，在自定义类的内部还是使用容器来存储接收的多个实参。

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Test
{
public:
    Test(std::initializer_list<string> list)
    {
        for (auto it = list.begin(); it != list.end(); ++it)
        {
            cout << *it << " ";
            m_names.push_back(*it);
        }
        cout << endl;
    }
private:
    vector<string> m_names;
};

int main(void)
{
    Test t({ "jack", "lucy", "tom" });
    Test t1({ "hello", "world", "nihao", "shijie" });
    return 0;
}
```

输出的结果:

```c++
jack lucy tom
hello world nihao shijie
```

# 6、using的使用

在C++中using用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在C++11中赋予了using新的功能，让C++变得更年轻，更灵活。

## 6.1 定义别名

在 C++中可以通过 **typedef** 重定义一个类型，语法格式如下：

```c++
typedef 旧的类型名 新的类型名;
// 使用举例
typedef unsigned int uint_t;
```

被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11中规定了一种新的方法，使用**别名声明(alias declaration)来定义类型的别名，即使用using**。

在使用的时候，关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。`类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。`

使用using定义别名的语法格式是这样的：

```c++
using 新的类型 = 旧的类型;
// 使用举例
using uint_t = int;
```

通过using和typedef的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了，看一下下面的例子：

```c++
// 使用typedef定义函数指针
typedef int(*func_ptr)(int, double);

// 使用using定义函数指针
using func_ptr1 = int(*)(int, double);
```

如果不是特别熟悉函数指针与typedef，第一眼很难看出func_ptr其实是一个别名，其本质是一个函数指针，指向的函数返回类型是int，函数参数有两个分别是int，double类型。

使用using定义函数指针别名的写法看起来就非常直观了，`把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边`，比较清晰，可读性比较好。

## 6.2 模板的别名

使用typedef重定义类似很方便，但是它有一点限制，比如无法重定义一个模板，比如我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:

```c++
typedef map<int, string> m1;
typedef map<int, int> m2;
typedef map<int, double> m3;
```

在这种情况下我们就不自觉的想到了模板：

```c++
template <typename T>
typedef map<int, T> type;	// error, 语法错误
```

使用typename不支持给模板定义别名，这个简单的需求仅通过typedef很难办到，需要添加一个**外敷类**：

```c++
#include <iostream>
#include <functional>
#include <map>
using namespace std;

template <typename T>
// 定义外敷类
struct MyMap
{
    typedef map<int, T> type;
};

int main(void)
{
    MyMap<string>::type m;
    m.insert(make_pair(1, "luffy"));
    m.insert(make_pair(2, "ace"));

    MyMap<int>::type m1;
    m1.insert(1, 100);
    m1.insert(2, 200);

    return 0;
}
```

通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。**在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名**，对于上面的需求可以写成这样：

```c++
template <typename T>
using mymap = map<int, T>;
```

完整的示例代码如下:

```c++
#include <iostream>
#include <functional>
#include <map>
using namespace std;

template <typename T>
using mymap = map<int, T>;

int main(void)
{
    // map的value指定为string类型
    mymap<string> m;
    m.insert(make_pair(1, "luffy"));
    m.insert(make_pair(2, "ace"));

    // map的value指定为int类型
    mymap<int> m1;
    m1.insert(1, 100);
    m1.insert(2, 200);

    return 0;
}
```

上面的例子中通过使用using给模板指定别名，就可以基于别名非常方便的给value指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。

**==最后在强调一点：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名==**。

# 7、可调用对象包装器、绑定器

## 7.1 可调用对象

在C++中存在“可调用对象”这么一个概念。准确来说，**可调用对象**有如下几种定义：

- `是一个函数指针`

  ```c++
  int print(int a, double b)
  {
      cout << a << b << endl;
      return 0;
  }
  // 定义函数指针
  int (*func)(int, double) = &print;
  ```

- `是一个具有operator()成员函数的类对象（仿函数）`

  ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  
  struct Test
  {
      // ()操作符重载
      void operator()(string msg)
      {
          cout << "msg: " << msg << endl;
      }
  };
  
  int main(void)
  {
      Test t;
      t("我是要成为海贼王的男人!!!");	// 仿函数
      return 0;
  }
  ```

- `是一个可被转换为函数指针的类对象`

  ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  
  using func_ptr = void(*)(int, string);
  struct Test
  {
      static void print(int a, string b)
      {
          cout << "name: " << b << ", age: " << a << endl;
      }
  
      // 将类对象转换为函数指针
      operator func_ptr()
      {
          return print;
      }
  };
  
  int main(void)
  {
      Test t;
      // 对象转换为函数指针, 并调用
      t(19, "Monkey D. Luffy");
  
      return 0;
  }
  ```

- `是一个类成员函数指针或者类成员指针`

  ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  
  struct Test
  {
      void print(int a, string b)
      {
          cout << "name: " << b << ", age: " << a << endl;
      }
      int m_num;
  };
  
  int main(void)
  {
      // 定义类成员函数指针指向类成员函数
      void (Test::*func_ptr)(int, string) = &Test::print;
      // 类成员指针指向类成员变量
      int Test::*obj_ptr = &Test::m_num;
  
      Test t;
      // 通过类成员函数指针调用类成员函数
      (t.*func_ptr)(19, "Monkey D. Luffy");
      // 通过类成员指针初始化类成员变量
      t.*obj_ptr = 1;
      cout << "number is: " << t.m_num << endl;
  
      return 0;
  }
  ```

在上面的例子中满足条件的这些可调用对象对应的类型被统称为`可调用类型`。C++中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，`C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。`

## 7.2 可调用对象包装器

**==std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类(非静态)成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们==**。

### 7.2.1 基本用法

std::function必须要包含一个叫做`functional`的头文件，可调用对象包装器使用语法如下:

```c++
#include <functional>
std::function<返回值类型(参数类型列表)> diy_name = 可调用对象;
```

下面的实例代码中演示了可调用对象包装器的基本使用方法：

```c++
#include <iostream>
#include <functional>
using namespace std;

int add(int a, int b)
{
    cout << a << " + " << b << " = " << a + b << endl;
    return a + b;
}

class T1
{
public:
    static int sub(int a, int b)
    {
        cout << a << " - " << b << " = " << a - b << endl;
        return a - b;
    }
};

class T2
{
public:
    int operator()(int a, int b)
    {
        cout << a << " * " << b << " = " << a * b << endl;
        return a * b;
    }
};

int main(void)
{
    // 绑定一个普通函数
    function<int(int, int)> f1 = add;
    // 绑定一个静态类成员函数
    function<int(int, int)> f2 = T1::sub;
    // 绑定一个仿函数
    T2 t;
    function<int(int, int)> f3 = t;

    // 函数调用
    f1(9, 3);
    f2(9, 3);
    f3(9, 3);

    return 0;
}
```

输入结果如下:

```c++
9 + 3 = 12
9 - 3 = 6
9 * 3 = 27
```

**==通过测试代码可以得到结论：std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了==**。

### 7.2.2 作为回调函数使用

因为回调函数本身就是通过函数指针实现的，`使用对象包装器可以取代函数指针的作用`，来看一下下面的例子：

```c++
#include <iostream>
#include <functional>
using namespace std;

class A
{
public:
    // 构造函数参数是一个包装器对象
    A(const function<void()>& f) : callback(f)
    {
    }

    void notify()
    {
        callback(); // 调用通过构造函数得到的函数指针
    }
private:
    function<void()> callback;
};

class B
{
public:
    void operator()()
    {
        cout << "我是要成为海贼王的男人!!!" << endl;
    }
};
int main(void)
{
    B b;
    A a(b); // 仿函数通过包装器对象进行包装
    a.notify();

    return 0;
}
```

通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。

另外，使用std::function作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。

## 7.3 绑定器

`std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候`。通俗来讲，它主要有两大作用：

1. `将可调用对象与其参数一起绑定成一个仿函数。`
2. `将多元（参数个数为n，n>1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。`

绑定器函数使用语法格式如下：

```c++
// 绑定非类成员函数/变量
auto f = std::bind(可调用对象地址, 绑定的参数/占位符);
// 绑定类成员函/变量
auto f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);
```

下面来看一个关于绑定器的实际使用的例子：

```c++
#include <iostream>
#include <functional>
using namespace std;

void callFunc(int x, const function<void(int)>& f)
{
    if (x % 2 == 0)
    {
        f(x);
    }
}

void output(int x)
{
    cout << x << " ";
}

void output_add(int x)
{
    cout << x + 10 << " ";
}

int main(void)
{
    // 使用绑定器绑定可调用对象和参数
    auto f1 = bind(output, placeholders::_1);
    for (int i = 0; i < 10; ++i)
    {
        callFunc(i, f1);
    }
    cout << endl;

    auto f2 = bind(output_add, placeholders::_1);
    for (int i = 0; i < 10; ++i)
    {
        callFunc(i, f2);
    }
    cout << endl;

    return 0;
}
```

测试代码输出的结果:

```c++
0 2 4 6 8
10 12 14 16 18
```

在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。`std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。`

`placeholders::_1`是一个占位符，`代表这个位置将在函数调用时被传入的第一个参数所替代`。同样还有其他的占位符`placeholders::_2`、`placeholders::_3`、`placeholders::_4`、`placeholders::_5`等……

有了占位符的概念之后，使得std::bind的使用变得非常灵活:

```c++
#include <iostream>
#include <functional>
using namespace std;

void output(int x, int y)
{
    cout << x << " " << y << endl;
}

int main(void)
{
    // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数
    bind(output, 1, 2)();
    bind(output, placeholders::_1, 2)(10);
    bind(output, 2, placeholders::_1)(10);

    // error, 调用时没有第二个参数
    // bind(output, 2, placeholders::_2)(10);
    // 调用时第一个参数10被吞掉了，没有被使用
    bind(output, 2, placeholders::_2)(10, 20);

    bind(output, placeholders::_1, placeholders::_2)(10, 20);
    bind(output, placeholders::_2, placeholders::_1)(10, 20);


    return 0;
}
```

示例代码执行的结果:

```c++
1  2		// bind(output, 1, 2)();
10 2		// bind(output, placeholders::_1, 2)(10);
2 10		// bind(output, 2, placeholders::_1)(10);
2 20		// bind(output, 2, placeholders::_2)(10, 20);
10 20		// bind(output, placeholders::_1, placeholders::_2)(10, 20);
20 10		// bind(output, placeholders::_2, placeholders::_1)(10, 20);
```

通过测试可以看到，std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。

可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器std::bind的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：

```c++
#include <iostream>
#include <functional>
using namespace std;

class Test
{
public:
    void output(int x, int y)
    {
        cout << "x: " << x << ", y: " << y << endl;
    }
    int m_number = 100;
};

int main(void)
{
    Test t;
    // 绑定类成员函数
    function<void(int, int)> f1 = 
        bind(&Test::output, &t, placeholders::_1, placeholders::_2);
    // 绑定类成员变量(公共)
    function<int&(void)> f2 = bind(&Test::m_number, &t);

    // 调用
    f1(520, 1314);
    f2() = 2333;
    cout << "t.m_number: " << t.m_number << endl;

    return 0;
}
```

示例代码输出的结果:

```c++
x: 520, y: 1314
t.m_number: 2333
```

在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。`f1的类型是function<void(int, int)>，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。`

**==使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function<int&(void)>的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void==**。

示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。













































































































































