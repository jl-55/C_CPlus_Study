# C++11新特性

参考：https://subingwen.cn/cplusplus/

# 第一篇——稳定性和兼容性

# 1、原始字面量

在C++11中添加了定义原始字符串的字面量，定义方式为：`R “xxx(原始字符串)xxx”`其中（）两边的字符串可以省略。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

比如：编程过程中，使用的字符串中常带有一些特殊字符，对于这些字符往往要做专门的处理，使用了原始字面量就可以轻松的解决这个问题了，比如打印路径：

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "D:\hello\world\test.text";
    cout << str << endl;
    string str1 = "D:\\hello\\world\\test.text";
    cout << str1 << endl;
    string str2 = R"(D:\hello\world\test.text)";
    cout << str2 << endl;

    return 0;
}
```

输出的结果为:

```c++
D:helloworld    est.text
D:\hello\world\test.text
D:\hello\world\test.text
```

- 在`D:\hello\world\test.text`中`\h`和`\w`转义失败，对应的字符会原样输出
- 在`D:\\hello\\world\\test.text`中路径的间隔符为`\`但是这个字符又是转义字符，因此需要使用转义字符将其转义，最终才能得到一个没有特殊含义的普通字符`\`
- 在`R"(D:\hello\world\test.text)"`使用了**原始字面量R（）中的内容就是描述路径的原始字符串**，无需做任何处理

通过测试可以看到，使用原始字面量R可以直接得到其原始意义的字符串，再看一个输出HTML标签的例子：

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "<html>\
        <head>\
        <title>\
        海贼王\
        </title>\
        </head>\
        <body>\
        <p>\
        我是要成为海贼王的男人!!!\
        </p>\
        </body>\
        </html>";
    cout << str << endl;
    return 0;
}
```

在C++11之前如果一个字符串分别写到了不同的行里边，需要**加连接符**，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = R"(<html>
        <head>
        <title>
        海贼王
        </title>
        </head>
        <body>
        <p>
        我是要成为海贼王的男人!!!
        </p>
        </body>
        </html>)";
    cout << str << endl;

    return 0;
}
```

最后强调一个细节：`在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。`

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str1 = R"(D:\hello\world\test.text)";
    cout << str1 << endl;
    string str2 = R"luffy(D:\hello\world\test.text)luffy";
    cout << str2 << endl;
#if 0
    // 加在()两边字符串必须在括号两边同时出现
    string str3 = R"luffy(D:\hello\world\test.text)robin";	// 语法错误，编译不通过
    cout << str3 << endl;
#endif

    return 0;
}
```

测试代码输出的结果为：

```c++
D:\hello\world\test.text
D:\hello\world\test.text
```

通过输出的信息可以得到如下结论：**使用原始字面量R “xxx(raw string)xxx”，（）两边的字符串在解析的时候是会被忽略的，因此一般不用指定。如果在（）前后指定了字符串，那么前后的字符串必须相同，否则会出现语法错误**。

# 2、超长整形long long

相比于C++98标准，C++11整型的最大改变就是多了`long long`。但事实上，long long 整型本来就离C++标准很近，早在1995年，long long 就被提议写入 C++98标准，却被C++标准委员会拒绝了。而后来，long long类型却进入了C99标准，而且也事实上也被很多编译器支持。于是辗转地，C++标准委员会又掉头决定将 long long纳入 C++11标准。

## 2.1 long long 类型

C++11 标准要求 long long 整型可以在不同平台上有不同的长度，但`至少有64位`。long long 整型有两种∶

- **long long - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀**

  ```c++
  long long num1 = 123456789LL;
  long long num2 = 123456789ll;
  ```

- **unsigned long long - 对应类型的数值可以使用 ULL (大写) 或者 ull (小写) 或者 Ull、uLL (等大小写混合)后缀**

  ```c++
  unsigned long long num1 = 123456789ULL;
  unsigned long long num2 = 123456789ull;
  unsigned long long num3 = 123456789uLL;
  unsigned long long num4 = 123456789Ull;
  ```

事实上在C++11中还有一些类型与以上两种类型是等价的:

- 对于有符号类型的 **long long** 和以下三种类型等价
  - `long long int`
  - `signed long long`
  - `signed long long int`
- 对于无符号类型的`unsigned long long` 和`unsigned long long int`是等价的

同其他的整型一样，要了解平台上 long long大小的方法就是查看`<climits>`（或`<limits. h>` ）中的宏与long long整 型相关的一共有3个：

- `LLONG_MIN` - 最小的long long值
- `LLONG_MAX` - 最大的long long 值
- `ULLONG MAX` - 最大的 unsigned long long 值

测试代码如下:

```c++
#include <iostream>
using namespace std;

int main()
{
    long long max = LLONG_MAX;
    long long min = LLONG_MIN;
    unsigned long long ullMax = ULLONG_MAX;

    cout << "Max Long Long value: " << max << endl
        << "Min Long Long value: " << min << endl
        << "Max unsigned Long Long value: " << ullMax << endl;
    return 0;
}
```

程序输出的结果:

```c++
Max Long Long value: 9223372036854775807
Min Long Long value: -9223372036854775808
Max unsigned Long Long value: 18446744073709551615
```

**可以看到 long long 类型能够存储的最大/最小值还是非常大/小的，但是这个值根据平台不同会有所变化，原因是因为C++11标准规定该类型至少占8字节，它占的字节数越多，对应能够存储的数值也就越大**。

## 2.2 扩展的整形

在C++11中一共只定义了以下5种标准的**有符号整型**：

- `signed char`
- `short int`
- `int`
- `long int`
- `long long int`

标准同时规定，每一种有符号整型都有一种对应的无符号整数版本，且有符号整型与其对应的无符号整型具有相同的存储空间大小。比如与 signed int对应的无符号版本的整型是 unsigned int。

当我们在C++中处理数据的时候，如果参与运算的数据或者传递的参数类型不匹配，整型间会发生隐式的转换，这种过程通常被称为整型的提升。比如如下表达式∶

```c++
(int)num1 + (long long)num2
```

关于这种整形提升的隐式转换遵循如下**原则**:

- 长度越大的整型等级越高，比如 `long long int` 的等级会高于`int`。
- 长度相同的情况下，标准整型的等级高于扩展类型，比如 `long long int` 和 `int64` 如果 都是64 位长度，则`long long int`类型的等级更高。 
- 相同大小的有符号类型和无符号类型的等级相同，`long long int` 和`unsigned longlong  int`的等级就相同。
- 转换过程中，低等级整型需要转换为高等级整型，有符号的需要转换为无符号整形。

# 附录1——32位系统与64位系统各数据类型对比

下面是32位系统与64位系统各数据类型对比：

| 数据类型           | 说明           | 32位字节数 | 64位字节数 | 取值范围                             |
| ------------------ | -------------- | ---------- | ---------- | ------------------------------------ |
| bool               | 布尔型         | 1          | 1          | true，false                          |
| char               | 字符型         | 1          | 1          | -128~127                             |
| unsigned char      | 无符号字符型   | 1          | 1          | 0~255                                |
| short              | 短整型         | 2          | 2          | -32768~32767                         |
| unsigned short     | 无符号短整型   | 2          | 2          | 0~65535                              |
| int                | 整型           | 4          | 4          | -2147483648~2147483647               |
| unsigned int       | 无符号整型     | 4          | 4          | 0~4294967295                         |
| long               | 长整型         | `4`        | `8`        | –                                    |
| unsigned long      | 无符号长整型   | `4`        | `8`        | –                                    |
| unsigned long long | 无符号超长整型 | 至少8      | 至少8      | 8字节取值范围: 0 ~ 264               |
| float              | 单精度浮点数   | 4          | 4          | 范围-2128 ~ 2128 精度为6~7位有效数字 |
| double             | 双精度浮点数   | 8          | 8          | 范围-21024 ~ 21024 精度为15~16位     |
| long double        | 扩展精度浮点数 | 8          | 8          | 范围-21024 ~ 21024 精度为15~16位     |
| *                  | 地址（指针）   | `4`        | `8`        | –                                    |

# 3、类成员的快速初始化

## 3.1 C++98标准的类成员初始化

在C++98中，支持了在类声明中使用**==等号 = 加初始值==** 的方式，来初始化类中**==静态成员常量==** 。这种声明方式我们也称之为**”就地”声明**。而`非静态成员变量的初始化则必须在构造函数中进行。`

下面通过一段代码来举例说明:

```c++
struct Base 
{
    Base() : a(250) {}
    Base(int num) : a(num) {}

    int a;
    int b = 1;	
    static int c = 0;	
    static const double d = 3.14;	
    static const char* const e = "i am luffy";	
    const static int f = 0;	
};
```

如果按照 C++98 标准来解读上面这段代码 ，其中有这么几行语法是错误的：

- 第7行：类的非静态成员，必须在构造函数中进行初始化

- 第8行：类的静态成员，必须在类的外部进行初始化

- 第9行：类的静态常量成员，`但不是整形或者枚举，无法通过编译`

  如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对C++的一个扩展，并不遵从C++ 标准。

- 第10行：类的静态常量成员，`但不是整形或者枚举，无法通过编译`

- 第8、9、10行的变量初始化方式是一样的，都是在类的外部

  ```c++
  int Base::c = 110;
  const double Base::d = 3.14;
  const char* const Base::e = "i am luffy";
  ```

> ==**答疑解惑：上面程序中的 static const 和 const static 是等价的**==。

## 3.2 C++11标准的类成员初始化

### 3.2.1 初始化类的非静态成员

在进行类成员变量初始化的时候，C++11标准对于C++98做了补充，**允许在定义类的时候在类内部直接对非静态成员变量进行初始化**，在初始化的时候可**以使用等号 =** 也**可以使用花括号 {}** 。

```c++
class Test
{
private:
    int a = 9;
    int b = {5};
    int c{12};
    double array[4] = { 3.14, 3.15, 3.16, 3.17};
    double array1[4] { 3.14, 3.15, 3.16, 3.17 };
    string s1("hello");     // error，- 不能使用小括号() 初始化对象，应该使用花括号{}
    string s2{ "hello, world" };
};
```

可以看到如果使用`花括号 {}`的方式对类的非静态成员进行初始化，等号是可以省略不写的。

- 第9行：错误，不能使用小括号() 初始化对象，应该使用花括号{}

### 3.2.2 类内部赋值和初始化列表

在C++11之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）。那么，如果同时在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？下面来测试一下：

> 初始化列表在进入构造函数之前就已经对成员变量进行了初始化

```c++
class Init
{
public:
    Init(int x, int y, int z) :a(x), b(y), c(z) {}

    int a = 1;
    int b = 2;
    int c = 3;
};

int main()
{
    Init tmp(10, 20, 30);
    cout << "a: " << tmp.a << ", b: " << tmp.b << ", c: " << tmp.c << endl;
    return 0;
}
```

- 第4行：使用**初始化列表**对类的非静态成员进行初始化
- 第6、7、8行：在类内部对非静态成员变量**就地初始化**（C++11新特性）

执行程序，输出的结果如下：

```c++
a: 10, b: 20, c: 30
```

我们可以从函数的打印输出中看到，在类内部就地初始化和初始化列表并不冲突（程序可以正常运行）。程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来`后作用于`非静态成员。也就是说，通过初始化列表指定的值会覆盖就地初始化时指定的值。

# 4、final和override

## 4.1 final

C++中增加了`final`关键字来`限制某个类不能被继承，或者某个虚函数不能被重写`，和Java的final关键字的功能是类似的。如果使用`final`修饰函数，只能修饰虚函数，并且`要把final关键字放到类或者函数的后面。`

### 4.1.1 修饰函数

如果使用`final`修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了：

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout << "GrandChild class...";
    }
};
```

在上面的代码中一共有三个类：

- 基类：Base
- 子类：Child
- 孙子类：GrandChild

`test()`是基类中的一个虚函数，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将`test()`方法标记为`final`，孙子类中对这个方法就只有使用的份了。

### 4.1.2 修饰类

使用`final`关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child final: public Base
{
public:
    void test()
    {
        cout << "Child class...";
    }
};

// error, 语法错误
class GrandChild : public Child
{
public:
};
```

`Child`类是被`final`修饰过的，因此`Child`类不允许有派生类`GrandChild`类的继承是非法的，`Child`是个断子绝孙的类

## 4.2 override

`override`关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样`这个关键字要写到方法的后面`。使用方法如下：

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};
```

上述代码中第13行和第22行就是显示指定了要重写父类的`test()`方法，使用了`override`关键字之后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率。

# 5、模块的优化

## 5.1 模板的右尖括号

在泛型编程中，模板实例化有一个非常繁琐的地方，那就是连续的两个右尖括号（**>>**）会被编译器解析成右移操作符，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板`Base`中提供了遍历容器的操作函数`traversal()`:

```c++
// test.cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
class Base
{
public:
    void traversal(T& t)
    {
        auto it = t.begin();
        for (; it != t.end(); ++it)
        {
            cout << *it << " ";
        }
        cout << endl;
    }
};


int main()
{
    vector<int> v{ 1,2,3,4,5,6,7,8,9 };
    Base<vector<int>> b;
    b.traversal(v);

    return 0;
}
```

如果使用`C++98/03`标准来编译上边的这段代码，就会得到如下的错误提示：

```c++
test.cpp:25:20: error: '>>' should be '> >' within a nested template argument list
     Base<vector<int>> b;
```

根据错误提示中描述模板的两个右尖括之间需要添加空格，这样写起来就非常的麻烦，`C++11改进了编译器的解析规则，尽可能地将多个右尖括号（>）解析成模板参数结束符`，方便我们编写模板相关的代码。

上面的这段代码，在支持C++11的编译器中编译是没有任何问题的，如果使用g++直接编译需要加参数`-std=c++11`：

```shell
$ g++ test.cpp -std=c++11 -o app
```

## 5.2 默认模版参数

在`C++98/03`标准中，类模板可以有默认的模板参数：

```c++
#include <iostream>
using namespace std;

template <typename T=int, T t=520>
class Test
{
public:
    void print()
    {
        cout << "current value: " << t << endl;
    }
};

int main()
{
    Test<> t;  // 哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随`<>`来实例化。
    t.print();

    Test<int, 1024> t1;
    t1.print();

    return 0;
}
```

但是不支持函数的默认模板参数，`在C++11中添加了对函数模板默认参数的支持`:

```c++
#include <iostream>
using namespace std;

template <typename T=int>	// C++98/03不支持这种写法, C++11中支持这种写法
void func(T t)
{
    cout << "current value: " << t << endl;
}

int main()
{
    func(100);
    return 0;
}
```

通过上面的例子可以得到如下结论：**当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随`<>`来实例化**。

**另外：函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制**。这样当默认模板参数和模板参数自动推导结合起来时，书写就显得非常灵活了。我们可以指定函数模板中的一部分模板参数使用默认参数，另一部分使用**自动推导**，比如下面的例子：

```c++
#include <iostream>
#include <string>
using namespace std;

template <typename R = int, typename N>
R func(N arg)
{
    return arg;
}

int main()
{
    auto ret1 = func(520);
    cout << "return value-1: " << ret1 << endl;

    auto ret2 = func<double>(52.134);
    cout << "return value-2: " << ret2 << endl;

    auto ret3 = func<int>(52.134);
    cout << "return value-3: " << ret3 << endl;

    auto ret4 = func<char, int>(100);
    cout << "return value-4: " << ret4 << endl;

    return 0;
}
```

测试代码输出的结果为:

```c++
return value-1: 520
return value-2: 52.134
return value-3: 52
return value-4: d  // a是97 ，100就是d
```

根据得到的日志输出，分析一下示例代码中调用的模板函数：

- **auto ret = func(520);**
  - 函数返回值类型使用了默认的模板参数，函数的参数类型是**自动推导**出来的为`int`类型。
- **auto ret1 = func<double>(52.134);**
  - 函数的返回值指定为`double`类型，函数参数类型是**通过实参推导**出来的，为`double`类型
- **auto ret3 = func<int>(52.134);**
  - 函数的返回值指定为`int`类型，函数参数类型是**通过实参推导**出来的，为`double`类型
- **auto ret4 = func<char, int>(100);**
  - 函数的参数为指定为`int`类型，函数返回值指定为`char`类型，不需要推导

当默认模板参数和模板参数自动推导同时使用时（优先级**从高到低**）：

- `如果可以推导出参数类型则使用推导出的类型`
- `如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数`
- `如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。`

看一下下面的例子：

```c++
#include <iostream>
#include <string>
using namespace std;

// 函数模板定义
template <typename T, typename U = char>
void func(T arg1 = 100, U arg2 = 100)
{
    cout << "arg1: " << arg1 << ", arg2: " << arg2 << endl;
}

int main()
{
    // 模板函数调用
    func('a');
    func(97, 'a');
    func('a', 97);
    // func();    //编译报错
    return 0;
}
```

程序输出的结果为:

```c++
arg1: a, arg2: d
arg1: 97, arg2: a
arg1: a, arg2: 97
```

分析一下调用的模板函数`func()`：

- `func('a')`：参数`T`被自动推导为`char`类型，`U`使用的默认模板参数为`char`类型
- `func(97, 'a');`：参数`T`被自动推导为`int`类型，`U`使用推导出的类型为`char`
- `func('a', 97);`：参数`T`被自动推导为`char`类型，`U`使用推导出的类型为`int`
- `func();`：参数T没有指定默认模板类型，并且无法自动推导，编译器会直接报错
  - `模板参数类型的自动推导是根据模板函数调用时指定的实参进行推断的`，没有实参则无法推导
  - 模板参数类型的自动推导不会参考函数模板中指定的默认参数。

# 6、数值类型和字符串之间的转换

在C++11中提供了专门的类型转换函数，程序猿可以非常方便的使用它们进行数值类型和字符串类型之间的转换。

## 6.1 数值转为字符串

使用`to_string()`方法可以非常方便地将各种数值类型转换为字符串类型，这是一个重载函，函数声明位于头文件`<string>`中，函数原型如下：

```c++
// 头文件 <string>
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);
```

关于函数的使用是非常简单的，示例代码如下：

```c++
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string pi = "pi is " + to_string(3.1415926);
    string love = "love is " + to_string(5.20 + 13.14);
    cout << pi << endl;
    cout << love << endl;
    return 0;
}
```

## 6.2 字符串转换为数值

由于C++中的数值类型包括`整形`和`浮点型`，因此针对于不同的类型提供了不同的函数，通过调用这些函数可以将字符串类型转换为对应的数值类型。

```c++
// 定义于头文件 <string>
int       stoi( const std::string& str, std::size_t* pos = 0, int base = 10 );
long      stol( const std::string& str, std::size_t* pos = 0, int base = 10 );
long long stoll( const std::string& str, std::size_t* pos = 0, int base = 10 );

unsigned long      stoul( const std::string& str, std::size_t* pos = 0, int base = 10 );
unsigned long long stoull( const std::string& str, std::size_t* pos = 0, int base = 10 );

float       stof( const std::string& str, std::size_t* pos = 0 );
double      stod( const std::string& str, std::size_t* pos = 0 );
long double stold( const std::string& str, std::size_t* pos = 0 );
```

- `str`：要转换的字符串
- `pos`：传出参数, 记录从哪个字符开始无法继续进行解析, 比如: 123`a`bc, 传出的位置为3
- `base`：若 base 为 0 ，则自动检测数值进制：若前缀为 `0` ，则为八进制，若前缀为 `0x` 或 `0X`，则为十六进制，否则为十进制。

这些函数虽然都有多个参数，但是除去第一个参数外其他都有默认值，一般情况下使用默认值就能满足需求。关于函数的使用也给大家提供了一个例子，示例代码如下：

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str1 = "45";
    string str2 = "3.14159";
    string str3 = "9527 with words";
    string str4 = "words and 2";

    int myint1 = std::stoi(str1);
    float myint2 = std::stof(str2);
    int myint3 = std::stoi(str3);
    // 错误： 'std::invalid_argument'
    // int myint4 = std::stoi(str4);

    cout << "std::stoi(\"" << str1 << "\") is " << myint1 << endl;
    cout << "std::stof(\"" << str2 << "\") is " << myint2 << endl;
    cout << "std::stoi(\"" << str3 << "\") is " << myint3 << endl;
    // cout << "std::stoi(\"" << str4 << "\") is " << myint4 << endl;
}
```

示例代码输入的结果如下：

```c++
std::stoi("45") is 45
std::stof("3.14159") is 3.14159
std::stoi("9527 with words") is 9527
```

从上述测试程序可以得出这样的结论，在C++11提供的这些转换函数将字符串转换为数值的过程中：

- `如果字符串中所有字符都是数值类型，整个字符串会被转换为对应的数值，并通过返回值返回`
- `如果字符串的前半部分字符是数值类型，后半部不是，那么前半部分会被转换为对应的数值，并通过返回值返回`
- `如果字符第一个字符不是数值类型转换失败`

# 7、静态断言 static_assert

## 7.1 断言

**断言（assertion）**是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判断表达式放在语句中，用于排除在设计的逻辑上不应该产生的情况。

比如：一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。 

从一些意义上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。

如果我们要在C++程序中使用断言，需要在程序中包含头文件`<cassert>`或`<assert.h>`，头文件中为我们提供了 ==assert== 宏，用于在运行时进行断言。举例说明：

```c++
#include <iostream>
#include <cassert>
using namespace std;

// 创建一个指定大小的 char 类型数组
char* createArray(int size)
{
    // 通过断言判断数组大小是否大于0
    assert(size > 0);	// 必须大于0, 否则程序中断
    char* array = new char[size];
    return array;
}

int main()
{
    char* buf = createArray(0);
    // 此处使用的是vs提供的安全函数, 也可以使用 strcpy
    strcpy_s(buf, 16, "hello, world!");
    cout << "buf = " << buf << endl;
    delete[]buf;
    return 0;
}
```

在程序的第9行，使用了断言==assert(expression)== ，这是一个宏，它的参数是一个表达式，这个表达式通常返回一个布尔类型的值，并且要求表达式必须为 ==true== 程序才能继续向下执行，否则会直接中断。

- 如果 `createArray`参数大于0，程序在16行正常运行直到结束

- 如果 `createArray`参数小于等于0，程序运行到16行直接退出，会看到如下图的提示信息：

  ![image-20241219111729110](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20241219111729110.png)

## 7.2 静态断言

在上面的例子中我们使用了断言 assert。但 **assert是一个运行时断言，也就是说它只有在程序运行时才能起作用** 。这意味着不运行程序我们将无法得知某些条件是否是成立的。 比如：我们想知道当前是32位还是64位平台，对于这个需求我们应该是在程序运行之前就应该得到结果，如果使用断言显然是无法做到的，对于这种情况我们就需要使用C++11提供的静态断言了。

静态断言`static_assert`，所谓静态就是`在编译时就能够进行检查的断言`，使用时**不需要引用头文件**。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。静态断言使用起来非常简单，它接收两个参数：

- `参数1：断言表达式，这个表达式通常需要返回一个 bool值`
- `参数2：警告信息，它通常就是一段字符串，在违反断言（表达式为false）时提示该信息`

由于基于VS计算的字节大小和理论值有出入，下面程序基于64位Linux进行测试，使用静态断言验证当前操作系统是否是32位：

```c++
// assert.cpp
#include <iostream>                                         
using namespace std;
  
int main()
{
    // 字体原因看起来是一个=, 其实这是两个=
    static_assert(sizeof(long) == 4, "错误, 不是32位平台...");
    cout << "64bit Linux 指针大小: " << sizeof(char*) << endl;
    cout << "64bit Linux long 大小: " << sizeof(long) <<endl;
  
    return 0;
}
```

通过g++编译程序：

```shell
$ g++ assert.cpp -std=c++11
assert.cpp: In function ‘int main()’:
assert.cpp:6:5: error: static assertion failed: 错误, 不是32位平台...
static_assert(sizeof(long) == 4, "错误, 不是32位平台...");
```

由于使用的Linux是64位的，因此在编译阶段静态断言检测条件失败，提示的错误信息就是我们给静态断言指定的第二个参数对应的那个字符串。

如果我们将静态断言的条件判断修改一下：

```c++
static_assert(sizeof(long) == 8, "错误, 不是64位平台...");
```

然后再进行编译:

```shell
$ g++ assert.cpp -std=c++11
```

编译通过，得到可执行程序`a.out`，然后执行这个程序可以看到如下输出：

```shell
$ ./a.out 
64bit Linux 指针大小: 8
64bit Linux long 大小: 8
```

静态断言条件判断为`true`，程序就可以继续向下执行了。

> **注意事项：**
>
> ==由于静态断言的表达式是在编译阶段进行检测，所以在它的表达式中不能出现变量，也就是说这个表达式必须是**常量表达式**==。

# 8、noexcept

## 8.1 异常

异常通常用于处理逻辑上可能发生的错误，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。

### 8.1.1 基本语法

关于异常的基本语法如下：

[![2016314153429533.jpg (577×329)](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/2016314153429533.jpg)](https://subingwen.cn/cpp/noexcept/2016314153429533.jpg)

```c++
int main()
{ 
    try
    {
        throw -1; 
    } 
    catch (int e)
    { 
        cout << "int exception, value: " << e << endl; 
    } 
    cout << "That's ok!" << endl; 
    return 0; 
}

输出:
int exception, value: -1
That's ok!
```

> **==异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。==**

### 8.1.2 异常接口声明

为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，常用的有如下三种书写方式：

1. 显示指定可以抛出的异常类型

   ```c++
   struct MyException
   {
       MyException(string s) :msg(s) {}
       string msg;
   };
   
   double divisionMethod(int a, int b) throw(MyException, int)
   {
       if (b == 0)
       {
           throw MyException("division by zero!!!");
           // throw 100;
       }
       return a / b;
   }
   
   int main()
   {
       try
       {	
           double v = divisionMethod(100, 0);
           cout << "value: " << v << endl;
       }
       catch (int e)
       {
           cout << "catch except: "  << e << endl;
       }
       catch (MyException e)
       {
           cout << "catch except: " << e.msg << endl;
       }
       return 0;
   }
   
   输出：
   catch except: division by zero!!!
   ```

   第7行代码在`divisionMethod`函数后添加了`throw`异常接口声明，其参数表示可以抛出的异常类型，分别为==int== 和==MyException== 类型。

2. 抛出任意异常类型

   ```c++
   struct MyException
   {
       MyException(string s) :msg(s) {}
       string msg;
   };
   
   double divisionMethod(int a, int b)
   {
       if (b == 0)
       {
           throw MyException("division by zero!!!");
           // throw 100;
       }
       return a / b;
   }
   
   输出：
   catch except: division by zero!!!
   ```

   第7行代码在`divisionMethod 没有添加异常接口声明`，表示在该函数中`可以抛出任意类型的异常`。

3. 不抛出任何异常

   ```c++
   struct MyException
   {
       MyException(string s) :msg(s) {}
       string msg;
   };
   
   double divisionMethod(int a, int b) throw()
   {
       if (b == 0)
       {
           cout << "division by zero!!!" << endl;
       }
       return a / b;
   }
   
   运行崩溃
   终端有输出"division by zero!!!" 
   ```

   第7行代码在`divisionMethod` 函数后添加了`throw`异常接口声明，其`参数列表为空`，表示该函数`不允许抛出异常`。

> **==温馨提示：以上程序在VS上的测试结果和在Linux上基于G++的测试结果是不同的，如果违反了规则VS只会给出警告，而G++则会直接终止程序的运行。（PS：VS使用的不是G++编译器）==**

## 8.2 noexcept

上面的例子中，在 `divisionMethod` 函数声明之后，我们定义了一个动态异常声明 `throw(MyException, int)`，该声明指出了`divisionMethod`可能抛出的异常的类型。事实上，**该特性很少被使用，因此在C++11中被弃用了** ，而表示函数不会抛出异常的动态异常声明 `throw() `也被新的 **noexcept** 异常声明所取代。 

**noexcept** 形如其名，表示**其修饰的函数不会抛出异常** 。不过与 `throw()`动态异常声明不同的是，`在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些`。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。

因此对于不会抛出异常的函数我们可以这样写:

```c++
#include <iostream>                                         
using namespace std;

struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) noexcept // 使用noexcept不抛出异常，
{
    if (b == 0)
    {
        cout << "division by zero!!!" << endl;
        return -1;
    }
    return a / b;
}

int main()
{
    try
    {
        double v = divisionMethod(100, 0);
        cout << "value: " << v << endl;
    }
    catch (int e)
    {
        cout << "catch except: " << e << endl;
    }
    catch (MyException e)
    {
        cout << "catch except: " << e.msg << endl;
    }
    return 0;
}

输出：
division by zero!!!
value: -1
```

从语法上讲，`noexcept` 修饰符有两种形式：

1. 简单地在函数声明后加上 noexcept 关键字

2. 可以接受一个常量表达式作为参数，如下所示∶

   ```c++
   double divisionMethod(int a, int b) noexcept(常量表达式);
   ```

   常量表达式的结果会被转换成一个bool类型的值：

   - 值为 true，表示函数不会抛出异常
   - 值为 false，表示有可能抛出异常这里
   - **不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常**。

# 第二篇——易学和易用性

# 1、自动推导类型

在C++11中增加了很多新的特性，比如可以使用auto自动推导变量的类型，还能够结合decltype来表示函数的返回值。使用新的特性可以让我们写出更加简洁，更加现代的代码。

## 1.1 auto

在C++11之前auto和static是对应的，表示变量是自动存储的，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，在C++11中他们赋予了新的含义，使用这个关键字能够像别的语言一样自动推导出变量的实际类型。

### 1.1.1 推导规则

C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，`使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。`使用语法如下：

```c++
auto 变量名 = 变量值;  // 必须初始化
```

根据上述语法，来列举一些简单的例子

```c++
auto x = 3.14;      // x 是浮点型 double
auto y = 520;       // y 是整形 int
auto z = 'a';       // z 是字符型 char
auto nb;            // error，变量必须要初始化
auto double nbl;    // 语法错误, 不能修改数据类型   
```

不仅如此，auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：

- **当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字**
- **当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字**

先来看一组变量带指针和引用并使用auto进行类型推导的例子：

```c++
int temp = 110;
auto *a = &temp;	// int
auto b = &temp;		// int*	
auto &c = temp;		// int	
auto d = temp;	    // int	
```

- 变量`a`的数据类型为 `int*`，因此auto关键字被推导为 `int类型`
- 变量`b`的数据类型为 `int*`，因此auto关键字被推导为 `int*`类型
- 变量`c`的数据类型为 `int&`，因此auto关键字被推导为 `int类型`
- 变量`d`的数据类型为 `int`，因此auto关键字被推导为 `int`类型

在来看一组带const限定的变量，使用auto进行类型推导的例子:

```c++
int tmp = 250;
const auto a1 = tmp;   // auto:int
auto a2 = a1;          // auto:int, 当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字
const auto &a3 = tmp;  // auto:int
auto &a4 = a3;         // auto:const int

auto* pt4 = &a1;       // auto:const int
```

- 变量`a1`的数据类型为 `const int`，因此auto关键字被推导为 `int`类型
- 变量`a2`的数据类型为 `int`，但是a2没有声明为指针或引用因此 const属性被去掉, `auto`被推导为 `int`
- 变量`a3`的数据类型为 `const int&`，a3被声明为引用因此 const属性被保留，auto关键字被推导为 `int`类型
- 变量`a4`的数据类型为 `const int&`，a4被声明为引用因此 const属性被保留，auto关键字被推导为 `const int`类型

### 1.1.2 auto的限制

auto关键字并不是万能的，在以下这些场景中是不能完成类型推导的：

1. **不能作为函数参数使用**。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。

   ```c++
   int func(auto a, auto b)	// error
   {	
       cout << "a: " << a <<", b: " << b << endl;
   }
   ```

2. **不能用于类的非静态成员变量的初始化**

   ```c++
   class Test
   {
       auto v1 = 0;                    // error
       static auto v2 = 0;             // error,类的静态非常量成员不允许在类内部直接初始化
       static const auto v3 = 10;      // ok
   }
   ```

3. **不能使用auto关键字定义数组**

   ```c++
   int func()
   {
       int array[] = {1,2,3,4,5};  // 定义数组
       auto t1 = array;            // ok, t1被推导为 int* 类型
       auto t2[] = array;          // error, auto无法定义数组
       auto t3[] = {1,2,3,4,5};;   // error, auto无法定义数组
   }
   ```

4. **无法使用auto推导出模板参数**

   ```c++
   template <typename T>
   struct Test{}
   
   int func()
   {
       Test<double> t;
       Test<auto> t1 = t;           // error, 无法推导出模板类型
       return 0;
   }
   ```

### 1.1.3 auto的应用

了解了auto的限制之后，我们就可以避开这些场景快乐的编程了，下面列举几个比较常用的场景：

1. `用于STL的容器遍历。`

   在C++11之前，定义了一个STL容器之后，遍历的时候常常会写出这样的代码：

   ```c++
   #include <map>
   int main()
   {
       map<int, string> person;
       map<int, string>::iterator it = person.begin();
       for (; it != person.end(); ++it)
       {
           // do something
       }
       return 0;
   }
   ```

   可以看到在定义迭代器变量 it 的时候代码是很长的，写起来就很麻烦，使用了auto之后，就变得清爽了不少：

   ```c++
   #include <map>
   int main()
   {
       map<int, string> person;
       // 代码简化
       for (auto it = person.begin(); it != person.end(); ++it)
       {
           // do something
       }
       return 0;
   }
   ```

2. `用于泛型编程`，在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，比如下面的代码：

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class T1
   {
   public:
       static int get()
       {
           return 10;
       }
   };
   
   class T2
   {
   public:
       static string get()
       {
           return "hello, world";
       }
   };
   
   template <class A>
   void func(void)
   {
       auto val = A::get();
       cout << "val: " << val << endl;
   }
   
   int main()
   {
       func<T1>();
       func<T2>();
       return 0;
   }
   
   输出：
   val: 10
   val: hello, world
   ```

   在这个例子中定义了泛型函数func，在函数中调用了类A的静态方法 get() ，这个函数的返回值是不能确定的，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下:

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class T1
   {
   public:
       static int get()
       {
           return 0;
       }
   };
   
   class T2
   {
   public:
       static string get()
       {
           return "hello, world";
       }
   };
   
   template <class A, typename B>        // 添加了模板参数 B
   void func(void)
   {
       B val = A::get();
       cout << "val: " << val << endl;
   }
   
   int main()
   {
       func<T1, int>();                  // 手动指定返回值类型 -> int
       func<T2, string>();               // 手动指定返回值类型 -> string
       return 0;
   }
   
   输出：
   val: 0
   val: hello, world
   ```

## 1.2 decltype

在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用C++11提供的decltype关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型，语法格式如下：

```c++
decltype (表达式)
```

**decltype** 是“**declare type**”的缩写，意思是“**声明类型**”。decltype的推导是在**编译期完成**的，它只是用于表达式类型的推导，并不会计算表达式的值。来看一组简单的例子：

```c++
int a = 10;
decltype(a) b = 99;                 // b -> int
decltype(a+3.14) c = 52.13;         // c -> double
decltype(a+b*c) d = 520.1314;       // d -> double
```

### 1.2.1 推导规则

通过上面的例子我们初步感受了一下 decltype 的用法，但不要认为 decltype 就这么简单，在它简单的背后隐藏着很多的细节，下面分三个场景依次讨论一下：

1. **表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的**。

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class Test
   {
   public:
       string text;
       static const int value = 110;
   };
   
   int main()
   {
       int x = 99;
       const int &y = x;            
       decltype(x) a = x;           // int
       decltype(y) b = x;           // const int &
       // 在代码中，decltype(Test::value) 推导出的类型是 const int，而不是 static const int，这是因为 decltype 仅推导类型本身，而不推导变量或成员的存储修饰符（如 static）。
       decltype(Test::value) c = 0; // const int
   
       Test t;
       decltype(t.text) d = "hello, world"; // string
   
       return 0;
   }
   ```

   - 变量`a`被推导为 `int`类型
   - 变量`b`被推导为 `const int &`类型
   - 变量`c`被推导为 `const int`类型
   - 变量`d`被推导为 `string`类型

2. **表达式是函数调用，使用decltype推导出的类型和函数==返回值==一致**。

   ```c++
   class Test{...};
   //函数声明
   int func_int();                 // 返回值为 int
   int& func_int_r();              // 返回值为 int&
   int&& func_int_rr();            // 返回值为 int&&
   
   const int func_cint();          // 返回值为 const int
   const int& func_cint_r();       // 返回值为 const int&
   const int&& func_cint_rr();     // 返回值为 const int&&
   
   const Test func_ctest();        // 返回值为 const Test
   
   //decltype类型推导
   int n = 100;
   decltype(func_int()) a = 0;		   // int
   decltype(func_int_r()) b = n;	   // int&
   decltype(func_int_r()) b = 0;      // 编译错误，因为 func_int_r() 返回的是 int&（左值引用），而 0 是一个右值，不能绑定到 int& 类型的变量上。
   decltype(func_int_rr()) c = 0;	   // int&&
   // func_cint()声明为返回const int。
   // 这里的重点是，即使函数返回类型是const int，decltype在推导时不会保留顶层const（除非与引用结合）。
   // 因此，推导出的类型是int，而不是const int。
   decltype(func_cint())  d = 0;	   // int  注意!!!
   decltype(func_cint_r())  e = n;	   // const int&
   decltype(func_cint_rr()) f = 0;	   // const int&&
   decltype(func_ctest()) g = Test(); // const Test
   ```

   - 变量`a`被推导为 `int`类型
   - 变量`b`被推导为 `int&`类型
   - 变量`c`被推导为 `int&&`类型
   - 变量`d`被推导为 `int`类型
   - 变量`e`被推导为 `const int &`类型
   - 变量`f`被推导为 `const int &&`类型
   - 变量`g`被推导为 `const Test`类型

   函数 func_cint() 返回的是一个**纯右值**（在表达式执行结束后不再存在的数据，也就是临时性的数据），`对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符`，因此推导出的变量d的类型为 int 而不是 const int。

3. **表达式是一个左值，或者被括号`( )`包围，使用 decltype推导出的是表达式类型==的引用==（如果有const、volatile限定符不能忽略）**。

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   
   class Test
   {
   public:
       int num;
   };
   
   int main() {
       const Test obj; // obj 是一个 const Test 对象。        
       // 带有括号的表达式
       // obj.num 是对 Test 类的成员变量 num 的访问。成员变量 num 是一个非 const 的 int。
       decltype(obj.num) a = 0;     // int。
       // obj 是 const Test，而 (obj.num) 是带括号的表达式。括号使得 obj.num 被作为一个表达式看待，而不是直接的标识符
       decltype((obj.num)) b = a;   // const int&
       // 加法表达式
       int n = 0, m = 0;
       decltype(n + m) c = 0;       // int
       decltype(n = n + m) d = n;   // int&
       return 0;
   }
   ```

   - `obj.num` 为类的成员访问表达式，符合场景1，因此 `a `的类型为`int`
   - `obj.num` 带有括号，符合场景3，因此`b` 的类型为 `const int&`。
   - `n+m` 得到一个右值，符合场景1，因此`c`的类型为 `int`
   - `n=n+m` 得到一个左值 n，符合场景3，因此`d`的类型为 `int&`

### 1.2.2 decltype的应用

关于decltype的应用多出现在泛型编程中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：

```c++
#include <list>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    ??? m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst;
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

在程序的第17行出了问题，关于迭代器变量一共有两种类型：`只读（T::const_iterator）`和`读写（T::iterator）`，有了decltype就可以完美的解决这个问题了，当 T 是一个 非 const 容器得到一个 T::iterator，当 T 是一个 const 容器时就会得到一个 `T::const_iterator`。

```c++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

`decltype(T().begin())`这种写法在vs2017/vs2019下测试可用完美运行。

## 1.3 返回类型后置

在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：

```c++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<decltype(x + y), int, double>(x, y);
    auto z = add<decltype(x + y)>(x, y);	// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

关于返回值，从上面的代码可以推断出和表达式 `t+u`的结果类型是一样的，因此可以通过通过decltype进行推导，关于模板函数的参数`t`和`u`可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。

因此如果要想解决这个问题就得直接在 `add` 函数身上做文章，先来看第一种写法：

```c++
template <typename T, typename U>
decltype(t+u) add(T t, U u)
{
    return t + u;
}
```

当我们在编译器中将这几行代码改出来后就直接**报错了**，因此decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。

`在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导`。其语法格式如下:

```c++
// 符号 -> 后边跟随的是函数返回值的类型
auto func(参数1, 参数2, ...) -> decltype(参数表达式)
```

通过对上述返回类型后置语法代码的分析，得到结论：`auto 会追踪 decltype() 推导出的类型`，因此上边的`add()`函数可以做如下的修改：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t+u) 
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<int, double>(x, y);
    auto z = add(x, y);		// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

为了进一步说明这个语法，我们再看一个例子：

```c++
#include <iostream>
using namespace std;

int& test(int &i)
{
    return i;
}

double test(double &d)
{
    d = d + 100;
    return d;
}

template <typename T>
// 返回类型后置语法
auto myFunc(T& t) -> decltype(test(t))
{
    return test(t);
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = myFunc<int>(x);
    auto z = myFunc(x);             // 简化之后的写法
    cout << "z: " << z << endl;

    // auto z = myFunc<double>(y);
    auto z1 = myFunc(y);            // 简化之后的写法
    cout << "z1: " << z1 << endl;
    return 0;
}
```

在这个例子中，通过decltype结合返回值后置语法很容易推导出来 `test(t)`函数可能出现的返回值类型，并将其作用到了函数`myFunc()`上。

```c++
// 输出结果
z: 520
z1: 113.14
```

# 2、基于范围的for循环

在C++98/03中，不同的容器和数组遍历的方式不尽相同，写法不统一，也不够简洁，而C++11基于范围的for循环可以以简洁、统一的方式来遍历容器和数组，用起来也更方便了。

## 2.1 for循环新语法

在介绍新语法之前，先来看一个使用迭代器遍历容器的例子

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (auto it = t.begin(); it != t.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
    
    return 0;
}
```

我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。`在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。`

C++98/03中普通的for循环，语法格式：

```c++
for(表达式 1; 表达式 2; 表达式 3)
{
    // 循环体
}
```

C++11基于范围的for循环，语法格式：

```c++
for (declaration : expression)
{
    // 循环体
}
```

在上面的语法格式中`declaration`表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。`expression`是要遍历的对象，它可以是`表达式`、`容器`、`数组`、`初始化列表`等。

使用基于范围的for循环遍历容器，示例代码如下：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (auto value : t)
    {
        cout << value << " ";
    }
    cout << endl;

    return 0;
}
```

在上面的例子中，**是将容器中遍历的当前元素拷贝到了声明的变量value中，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用**。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    cout << "遍历修改之前的容器: ";
    for (auto &value : t)
    {
        cout << value++ << " ";
    }
    cout << endl << "遍历修改之后的容器: ";

    for (auto &value : t)
    {
        cout << value << " ";
    }
    cout << endl;

    return 0;
}
```

代码输出的结果：

```c++
遍历修改之前的容器: 1 2 3 4 5 6
遍历修改之后的容器: 2 3 4 5 6 7
```

对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用`const`定义保存元素数据的变量，在定义的时候建议使用`const auto &`，这样相对于`const auto`效率要更高一些。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (const auto& value : t)
    {
        cout << value << " ";
    }

    return 0;
}
```

## 2.2 使用细节

### 2.2.1 关系型容器

使用基于范围的for循环有一些需要注意的细节，先来看一下对关系型容器map的遍历：

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    // 基于范围的for循环方式
    for (auto& it : m)
    {
        cout << "id: " << it.first << ", name: " << it.second << endl;
    }

    // 普通的for循环方式
    for (auto it = m.begin(); it != m.end(); ++it)
    {
        cout << "id: " << it->first << ", name: " << it->second << endl;
    }

    return 0;
}
```

在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：

1. **使用普通的for循环方式（基于迭代器）遍历关联性容器， auto自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）**：
   - it->first
   - it->second
2. **使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下**：
   - it.first
   - it.second

### 2.2.2 元素只读

通过对基于范围的for循环语法的介绍可以得知，在for循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，**对应set容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在for循环中auto&会被视为const auto &** 。

```c++
#include <iostream>
#include <set>
using namespace std;

int main(void)
{
    set<int> st{ 1,2,3,4,5,6 };
    for (auto &item : st) 
    {
        cout << item++ << endl;		// error, 不能给常量赋值
    }
    return 0;
}
```

除此之外，`在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。`

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    for (auto& item : m)
    {
        // item.first 是一个常量
        cout << "id: " << item.first++ << ", name: " << item.second << endl;  // error
    }

    return 0;
}
```

### 2.2.3 访问次数

基于范围的for循环遍历的对象可以是一个表达式或者容器/数组等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：

```c++
#include <iostream>
#include <vector>
using namespace std;

vector<int> v{ 1,2,3,4,5,6 };
vector<int>& getRange()
{
    cout << "get vector range..." << endl;
    return v;
}

int main(void)
{
    for (auto val : getRange())
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

输出的结果如下：

```c++
get vector range...
1 2 3 4 5 6
```

从上面的结果中可以看到，不论基于范围的for循环迭代了多少次，函数getRange()只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了

> ==**结论：**==
>
> ==**对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。**==

# 3、指针空值类型——nullptr

在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为`NULL`，避免产生`野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）`。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：

```c++
char *ptr = 0;
char *ptr = NULL;
```

在底层源码中`NULL`这个宏是这样定义的:

```c
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

也就是说如果源码是C++程序`NULL`就是`0`，如果是C程序`NULL`表示`(void*)0`。那么为什么要这样做呢？ 是由于 C++ 中，`void *` 类型无法隐式转换为其他类型的指针，此时使用 `0` 代替 `((void *)0)`，用于解决空指针的问题。这个0（0x0000 0000）表示的就是虚拟地址空间中的0地址，这块地址是只读的。

虚拟地址空间结构图：

[![img](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20210130093015907.png)](https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png)

C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，`NULL` 和 `0` 无法区分：

```c++
#include <iostream>
using namespace std;

void func(char *p)
{
    cout << "void func(char *p)" << endl;
}

void func(int p)
{
    cout << "void func(int p)" << endl;
}

int main()
{
    func(NULL);   // 想要调用重载函数 void func(char *p)
    func(250);    // 想要调用重载函数 void func(int p)

    return 0;
}
```

测试代码打印的结果为：

```c++
void func(int p)
void func(int p)
```

通过打印的结果可以看到，虽然调用`func(NULL);`最终链接到的还是`void func(int p)`和预期是不一样的，其实这个原因前边已经说的很明白了，在C++中`NULL`和`0`是等价的。

出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另起炉灶，引入了一个新的关键字`nullptr`。`nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化`

```c++
int*    ptr1 = nullptr;
char*   ptr2 = nullptr;
double* ptr3 = nullptr;
```

对应上面的代码编译器会分别将 `nullptr` 隐式转换成` int*`、`char*` 以及 `double*` 指针类型。

使用`nullptr`可以很完美的解决上边提到的函数重载问题:

```c++
#include <iostream>
using namespace std;

void func(char *p)
{
    cout << "void func(char *p)" << endl;
}

void func(int p)
{
    cout << "void func(int p)" << endl;
}

int main()
{
    func(nullptr);
    func(250);
    return 0;
}
```

测试代码输出的结果:

```c++
void func(char *p)
void func(int p)
```

通过输出的结果可以看出，**nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型**。**在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮**。

# 4、Lambda表达式

## 4.1 基本用法

lambda表达式是C++11最重要也是最常用的特性之一，这是现代编程语言的一个特点，lambda表达式有如下的一些**优点**：

- 声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。
- 简洁：避免了代码膨胀和功能分散，让开发更加高效。
- 在需要的时间和地点实现功能闭包，使程序更加灵活。

lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式简单归纳如下：

```c++
[capture](params) opt -> ret {body;};
```

其中`capture`是捕获列表，`params`是参数列表，`opt`是函数选项，`ret`是返回值类型，`body`是函数体。

1. 捕获列表[]: 捕获一定范围内的变量

2. 参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。

   ```c++
   auto f = [](){return 1;}	// 没有参数, 参数列表为空
   auto f = []{return 1;}		// 没有参数, 参数列表省略不写
   ```

3. opt 选项， `不需要可以省略`

   - **mutable**: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
   - **exception**: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();

4. 返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。

5. 函数体：函数的实现，这部分**不能省略，但函数体可以为空**。

## 4.2 捕获列表

lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：

- `[] `- 不捕捉任何变量
- `[&] `- 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (`按引用捕获`)
- `[=] `- 捕获外部作用域中所有变量, 并作为副本在函数体内使用(`按值捕获`)
  - `拷贝的副本在匿名函数体内部是只读的`
- `[=, &foo]` - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo
- `[bar]` - 按值捕获 bar 变量, 同时不捕获其他变量
- `[&bar]` - 按引用捕获 bar 变量, 同时不捕获其他变量
- `[this]` - 捕获当前类中的this指针
  - 让lambda表达式拥有和当前类成员函数同样的访问权限
  - 如果已经使用了 & 或者 =, 默认添加此选项

下面通过一个例子，看一下初始化列表的具体用法

```c++
#include <iostream>
#include <functional>
using namespace std;

class Test
{
public:
    void output(int x, int y)
    {
        auto x1 = [] {return m_number; };                      // error,没有捕获外部变量，不能使用类成员 m_number
        auto x2 = [=] {return m_number + x + y; };             // ok
        auto x3 = [&] {return m_number + x + y; };             // ok
        auto x4 = [this] {return m_number; };                  // ok
        auto x5 = [this] {return m_number + x + y; };          // error,捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。
        auto x6 = [this, x, y] {return m_number + x + y; };    // ok
        auto x7 = [this] {return m_number++; };                // ok
    }
    int m_number = 100;
};
```

- `x1`：错误，没有捕获外部变量，不能使用类成员 m_number
- `x2`：正确，以值拷贝的方式捕获所有外部变量
- `x3`：正确，以引用的方式捕获所有外部变量
- `x4`：正确，捕获this指针，可访问对象内部成员
- `x5`：错误，捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。
- `x6`：正确，捕获this指针，x，y
- `x7`：正确，捕获this指针，并且可以修改对象内部变量的值

```c++
int main(void)
{
    int a = 10, b = 20;
    auto f1 = [] {return a; };                        // error,没有捕获外部变量，因此无法访问变量 a
    auto f2 = [&] {return a++; };                     // ok
    auto f3 = [=] {return a; };                       // ok
    auto f4 = [=] {return a++; };                     // error，使用值拷贝的方式捕获外部变量，可读不能写
    auto f5 = [a] {return a + b; };                   // error，使用拷贝的方式捕获了外部变量a，没有捕获外部变量b，因此无法访问变量b
    auto f6 = [a, &b] {return a + (b++); };           // ok
    auto f7 = [=, &b] {return a + (b++); };           // ok

    return 0;
}
```

- `f1`：错误，没有捕获外部变量，因此无法访问变量 a
- `f2`：正确，使用引用的方式捕获外部变量，可读写
- `f3`：正确，使用值拷贝的方式捕获外部变量，可读
- `f4`：错误，使用值拷贝的方式捕获外部变量，可读不能写
- `f5`：错误，使用拷贝的方式捕获了外部变量a，没有捕获外部变量b，因此无法访问变量b
- `f6`：正确，使用拷贝的方式捕获了外部变量a，只读，使用引用的方式捕获外部变量b，可读写
- `f7`：正确，使用值拷贝的方式捕获所有外部变量以及b的引用，b可读写，其他只读

> **==在匿名函数内部，需要通过lambda表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下lambda表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。==**

## 4.3 返回值

很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。

```c++
// 完整的lambda表达式定义
auto f = [](int a) -> int
{
    return a+10;  
};

// 忽略返回值的lambda表达式定义
auto f = [](int a)
{
    return a+10;  
};
```

一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是`labmda表达式不能通过列表初始化自动推导出返回值类型。`

```c++
// ok，可以自动推导出返回值类型
auto f = [](int i)
{
    return i;
}

// error，不能推导出返回值类型
auto f1 = []()
{
    return {1, 2};	// 基于列表初始化推导返回值，错误
```

## 4.4 函数本质

使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用**mutable**选项，`被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。`

```c++
int a = 0;
auto f1 = [=] {return a++; };              // error, 按值捕获外部变量, a是只读的
auto f2 = [=]()mutable {return a++; };     // ok
```

最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:

1. `lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。`
2. `按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。`

mutable选项的作用就在于取消operator()的const属性。

因为lambda表达式在C++中会被看做是一个仿函数，因此`可以使用std::function和std::bind来存储和操作lambda表达式`：

```c++
#include <iostream>
#include <functional>
using namespace std;

int main(void)
{
    // 包装可调用函数
    std::function<int(int)> f1 = [](int a) {return a; };
    // 绑定可调用函数
    std::function<int(int)> f2 = bind([](int a) {return a; }, placeholders::_1);

    // 函数调用
    cout << f1(100) << endl;
    cout << f2(200) << endl;
    return 0;
}
```

**对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针**：

```c++
using func_ptr = int(*)(int);
// 没有捕获任何外部变量的匿名函数
func_ptr f = [](int a)
{
    return a;  
};
// 函数调用
f(1314);
```

# 第三篇——通用性能的提升

# 1、constexpr

### 1.1.1 const

在C++11之前只有`const`关键字，从功能上来说这个关键字有双重语义：`变量只读`，`修饰常量`，举一个简单的例子：

```c++
void func(const int num)
{
    const int count = 24;
    int array[num];            // error，num是一个只读变量，不是常量
    int array1[count];         // ok，count是一个常量

    int a1 = 520;
    int a2 = 250;
    const int& b = a1;
    b = a2;                         // error
    a1 = 1314;
    cout << "b: " << b << endl;     // 输出结果为1314
}
```

- 函数`void func(const int num)`的参数`num`表示这个变量是只读的，但不是常量，因此使用`int array[num]; `这种方式定义一个数组，编译器是会报错的，提示`num不可用作为常量来使用`。
- `const int count = 24;`中的`count`却是一个常量，因此可以使用这个常量来定义一个静态数组。

另外，`变量只读并不等价于常量`，二者是两个概念不能混为一谈，分析一下这句测试代码`const int& b = a1;`：

- `b`是一个常量的引用，所以b引用的变量是不能被修改的，也就是说`b = a2; `这句代码语法是错误的。
- 在`const`对于变量`a1`是没有任何约束的，`a1`的值变了`b`的值也就变了
- 引用`b`是只读的，但是并不能保证它的值是不可改变的，也就是说它不是常量。

### 1.1.2 constexpr

在C++11中添加了一个新的关键字`constexpr`，这个关键字是用来修饰常量表达式的。所谓`常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。`

在介绍gcc/g++工作流程的时候说过，C++ 程序从编写完毕到执行分为四个阶段：`预处理`、 `编译`、`汇编`和`链接`4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，`常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率`，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。

那么问题来了，编译器如何识别表达式是不是常量表达式呢？在C++11中添加了`constexpr`关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 `const` 和 `constexpr` 的功能区分开，即`凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。`

在定义常量时，`const` 和 `constexpr` 是等价的，都可以在程序的编译阶段计算出结果，例如：

```c++
const int m = f();  // 不是常量表达式，m的值只有在运行时才会获取。
const int i=520;    // 是一个常量表达式
const int j=i+1;    // 是一个常量表达式

constexpr int i=520;    // 是一个常量表达式
constexpr int j=i+1;    // 是一个常量表达式
```

对于 C++ 内置类型的数据，可以直接用 `constexpr` 修饰，但如果是自定义的数据类型（用 `struct` 或者 `class` 实现），直接用 `constexpr` 修饰是不行的。

```c++
// 此处的constexpr修饰是无效的
constexpr struct Test
{
    int id;
    int num;
};
```

如果要定义一个结构体/类常量对象，可以这样写：

```c++
struct Test
{
    int id;
    int num;
};

int main()
{
    constexpr Test t{ 1, 2 };
    constexpr int id = t.id;
    constexpr int num = t.num;
    // error，不能修改常量
    t.num += 100;
    cout << "id: " << id << ", num: " << num << endl;

    return 0;
}
```

在第13行的代码中`t.num += 100;`的操作是错误的，对象`t`是一个常量，因此它的成员也是常量，常量是不能被修改的。

## 1.2 常量表达式函数

为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用`constexpr`修饰函数的返回值，这种函数被称作`常量表达式函数`，这些函数主要包括以下几种：`普通函数/类成员函数`、`类的构造函数`、`模板函数`。

### 1.2.1 修饰函数

> **==温馨提示：由于现在编译器版本都比较高，默认的使用的C++标准也比较高（大于C++11），相关源代码请基于 C++11 标准进行测试。==**

`constexpr`并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：

1. 函数必须要有返回值，并且return 返回的表达式必须是常量表达式。

   ```c++
   // error，不是常量表达式函数
   constexpr void func1()
   {
       int a = 100;
       cout << "a: " << a << endl;
   }
   
   // error，不是常量表达式函数
   constexpr int func1()
   {
       int a = 100;
       return a;
   }
   ```

   - 函数`func1()`没有返回值，不满足常量表达式函数要求

   - 函数`func2()`返回值不是常量表达式，不满足常量表达式函数要求

     [![image-20230513082727668](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20230513082727668.png)](https://subingwen.cn/cpp/constexpr/image-20230513082727668.png)

   由此可见在`更新的C++标准`里边放宽了对`constexpr`的语法限制。

2. 函数在使用之前，必须有对应的定义语句。**函数的声明跟实现都要在函数的使用前面**

   ```c++
   #include <iostream>
   using namespace std;
   
   constexpr int func1();
   int main()
   {
       constexpr int num = func1();	// error
       return 0;
   }
   
   constexpr int func1()
   {
       constexpr int a = 100;
       return a;
   }
   ```

   在测试程序`constexpr int num = func1();`中，还没有定义`func1()`就直接调用了，应该将`func1()`函数的定义放到`main()`函数的上边。

3. 整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return语句除外）。

   ```c++
   // error
   constexpr int func1()
   {
       constexpr int a = 100;
       constexpr int b = 10;
       for (int i = 0; i < b; ++i)
       {
           cout << "i: " << i << endl;
       }
       return a + b;
   }
   
   // ok
   constexpr int func2()
   {
       using mytype = int;
       constexpr mytype a = 100;
       constexpr mytype b = 10;
       constexpr mytype c = a * b;
       return c - (a + b);
   }
   ```

   因为`func1()`是一个常量表达式函数，在函数体内部是**不允许出现非常量表达式以外的操作**，因此函数体内部的`for`循环是一个非法操作。

> 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：

```c++
class Test
{
public:
    constexpr int func()
    {
        constexpr int var = 100;
        return 5 * var;
    }
};

int main()
{
    Test t;
    constexpr int num = t.func();
    cout << "num: " << num << endl;

    return 0;
}
```

### 1.2.2 修饰模板函数

C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。`如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。`

```c++
#include <iostream>
using namespace std;

struct Person {
    const char* name;
    int age;
};

// 定义函数模板
template<typename T>
constexpr T display(T t) {
    return t;
}

int main()
{
    struct Person p { "luffy", 19 };
    //普通函数
    struct Person ret = display(p);
    cout << "luffy's name: " << ret.name << ", age: " << ret.age << endl;

    //常量表达式函数
    constexpr int ret1 = display(250);
    cout << ret1 << endl;

    constexpr struct Person p1 { "luffy", 19 };
    constexpr struct Person p2 = dispaly(p1);
    cout << "luffy's name: " << p2.name << ", age: " << p2.age << endl;
    return 0;
}
```

在上面示例程序中定义了一个函数模板 `display()`，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：

- `struct Person ret = display(p);`由于参数`p`是变量，所以实例化后的函数不是常量表达式函数，此时 `constexpr` 是无效的
- `constexpr int ret1 = display(250);`参数是常量，符合常量表达式函数的要求，此时 `constexpr` 是有效的
- `constexpr struct Person p2 = display(p1);`参数是常量，符合常量表达式函数的要求，此时 `constexpr` 是有效的

### 1.2.3 修饰构造函数

如果想用直接得到一个常量对象，也可以使用`constexpr`修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：`构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。`

```c++
#include <iostream>
using namespace std;

struct Person {
    constexpr Person(const char* p, int age) :name(p), age(age)
    {
    }
    const char* name;
    int age;
};

int main()
{
    constexpr struct Person p1("luffy", 19);
    cout << "luffy's name: " << p1.name << ", age: " << p1.age << endl;
    return 0;
}
```

# 2、委托构造和集成构造函数

## 2.1 委托构造函数

委托构造函数**允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化**。下面举例说明：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min)
    {
        this->m_max = max > 0 ? max : 100;              // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;   
    }

    Test(int max, int min, int mid)
    {
        this->m_max = max > 0 ? max : 100;             // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;  // 冗余代码
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};

int main()
{
    Test t(90, 30, 60);
    cout << "min: " << t.m_min << ", middle: " 
         << t.m_middle << ", max: " << t.m_max << endl;
    return 0;
}
```

在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min):Test(max)
    {
        this->m_min = min > 0 && min < max ? min : 1;
    }

    Test(int max, int min, int mid):Test(max, min)
    {
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};

int main()
{
    Test t(90, 30, 60);
    cout << "min: " << t.m_min << ", middle: " 
         << t.m_middle << ", max: " << t.m_max << endl;
    return 0;
}
```

在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：

- **这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。**

- **如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。**

  ```c++
  Test(int max)
  {
      this->m_max = max > 0 ? max : 100;
  }
  
  Test(int max, int min)
  {
      Test(max);	// error, 此处编译器会报错, 提示形参max被重复定义
      this->m_min = min > 0 && min < max ? min : 1;
  }
  ```

- **在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了**。

  ```c++
  // 错误, 使用了委托构造函数就不能再次m_max初始化了
  Test(int max, int min) : Test(max), m_max(max)
  {
      this->m_min = min > 0 && min < max ? min : 1;
  }
  ```

## 2.2 继承构造函数

C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    Child(int i) :Base(i) {}
    Child(int i, double j) :Base(i, j) {}
    Child(int i, double j, string k) :Base(i, j, k) {}
};

int main()
{
    Child c(520, 13.14, "i love you");
    cout << "int: " << c.m_i << ", double: " 
         << c.m_j << ", string: " << c.m_k << endl;
    return 0;
}
```

通过测试代码可以看出，在子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数，这是非常繁琐的，C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。

继承构造函数的使用方法是这样的：通过使用`using 类名::构造函数名`（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;  // 可以在子类使用父类所有的构造函数
};

int main()
{
    Child c1(520, 13.14);
    cout << "int: " << c1.m_i << ", double: " << c1.m_j << endl;
    Child c2(520, 13.14, "i love you");
    cout << "int: " << c2.m_i << ", double: " 
         << c2.m_j << ", string: " << c2.m_k << endl;
    return 0;
}
```

在修改之后的子类中，没有添加任何构造函数，而是添加了`using Base::Base;`这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。

另外如果在子类中隐藏了父类中的同名函数，也可以通过`using`的方式在子类中使用基类中的这些父类函数：

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    void func(int i)
    {
        cout << "base class: i = " << i << endl;
    }
    
    void func(int i, string str)
    {
        cout << "base class: i = " << i << ", str = " << str << endl;
    }

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;   // 继承父类的构造函数
    using Base::func;   // 当子类有跟父类同名的函数时，父类的同名函数会被隐藏，添加这句代码之后，子类才可以调用父类被隐藏的同名函数
    void func()
    {
        cout << "child class: i'am luffy!!!" << endl;
    }
};

int main()
{
    Child c(250);
    c.func();
    c.func(19);
    c.func(19, "luffy");
    return 0;
}
```

上述示例代码输出的结果为：

```c++
child class: i'am luffy!!!
base class: i = 19
base class: i = 19, str = luffy
```

子类中的`func()`函数隐藏了基类中的两个`func()`因此默认情况下通过子类对象只能调用无参的`func()`，在上面的子类代码中添加了`using Base::func;`之后，就可以通过子类对象直接调用父类中被隐藏的带参`func()`函数了。

# 3、右值引用

## 3.1 右值引用

### 3.1.1 右值

C++11 增加了一个新的类型，称为**右值引用**（ R-value reference），标记为` &&`。在介绍右值引用类型之前先要了解什么是左值和右值：

- lvalue 是`locator value`的缩写，rvalue 是 `read value`的缩写;
- **左值**是指存储在内存中、有明确存储地址（可取地址）的数据；
- **右值**是指可以提供数据值的数据（不可取地址）；

通过描述可以看出，区分左值与右值的便捷方法是：**可以对表达式取地址（&）就是左值**，否则为右值 。**所有有名字的变量或对象都是左值**，而**右值是匿名的**。

```c++
int a = 520;
int b = 1314;
a = b;
```

**一般情况下，位于`=`前的表达式为左值，位于`=`后边的表达式为右值**。也就是说例子中的`a, b`为左值，`520,1314`为右值。`a=b`是一种特殊情况，在这个表达式中`a, b`都是左值，因为变量`b`是可以被取地址的，不能视为右值。

C++11 中右值可以分为两种：一个是**将亡值**（ xvalue, expiring value），另一个则是**纯右值**（ prvalue, PureRvalue）：

- `纯右值`：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等
- `将亡值`：与右值引用相关的表达式，比如，T&&类型函数的返回值、 std::move 的返回值等。

```c++
int value = 520;
```

在上面的语句中，value是左值，520是字面量也就是右值。其中value可以被引用，但是520就不行了，因为字面量都是右值。

### 3.1.2 右值引用

右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。`无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”`，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

关于右值引用的使用，参考代码如下：

```c++
#include <iostream>
using namespace std;

int&& value = 520;
class Test
{
public:
    Test()
    {
        cout << "construct: my name is jerry" << endl;
    }
    Test(const Test& a)
    {
        cout << "copy construct: my name is tom" << endl;
    }
};

// 该函数返回一个临时的 Test 对象（右值），通过 return Test(); 创建并返回一个 Test 类型的临时对象
Test getObj()
{
    return Test();
}

int main()
{
    int a1;
    int &&a2 = a1;        // error,a1是左值，不能右值引用
    Test& t = getObj();   // error，右值不能给普通的左值引用赋值。
    Test && t = getObj();
    // 常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。
    const Test& t = getObj();
    
    return 0;
}
```

- 在上面的例子中`int&& value = 520;`里面`520`是纯右值，`value`是对字面量`520`这个右值的引用。
- 在`int &&a2 = a1;`中`a1`虽然写在了`=`右边，但是它仍然是一个左值，`使用左值初始化一个右值引用类型是不合法的。`
- 在`Test& t = getObj()`这句代码中语法是错误的，`右值不能给普通的左值引用赋值。`
- 在`Test && t = getObj();`中`getObj()`返回的`临时对象`被称之为`将亡值`，`t`是这个将亡值的右值引用。
- `const Test& t = getObj()`这句代码的语法是正确的，`常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。`

## 3.2 性能优化

在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以**使用右值引用进行性能的优化**。

再来修改一下上面的实例代码：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() : m_num(new int(100))  // 构造函数
    {
        cout << "construct: my name is jerry" << endl;
    }

    Test(const Test& a) : m_num(new int(*a.m_num))  // 拷贝构造函数
    {
        cout << "copy construct: my name is tom" << endl;
    }

    ~Test()  // 析构函数
    {
        delete m_num;  // 释放分配的内存
    }

    int* m_num;  // 指针成员
};

Test getObj()
{
    Test t;  // 创建局部变量 t
    return t;  // 返回 t，触发拷贝构造或移动构造
}

int main()
{
    Test t = getObj();  // 返回值会触发拷贝或移动构造
    cout << "t.m_num: " << *t.m_num << endl;  // 输出 t.m_num 的值
    return 0;
}
```

测试代码执行的结果为（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）:

```c++
construct: my name is jerry
copy construct: my name is tom
t.m_num: 100
```

通过输出的结果可以看到调用`Test t = getObj();`的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到了对象`t`，在`getObj()`函数中创建的对象虽然进行了内存的申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省资源申请和释放的时间，如果要执行这样的操作就需要使用右值引用了，右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() : m_num(new int(100))
    {
        cout << "construct: my name is jerry" << endl;
    }

    Test(const Test& a) : m_num(new int(*a.m_num))
    {
        cout << "copy construct: my name is tom" << endl;
    }

    // 添加移动构造函数 -> 复用其他对象中的资源（堆内存）
    Test(Test&& a) : m_num(a.m_num)
    {
        a.m_num = nullptr;    // 使原对象的指针失效
        cout << "move construct: my name is sunny" << endl;
    }

    ~Test()
    {
        delete m_num;
        cout << "destruct Test class ..." << endl;
    }

    int* m_num;
};

Test getObj()
{
    Test t;
    return t;
}

int main()
{
    // 要求右侧对象是一个临时对象，才会调用移动构造函数
    // 如果没有移动构造函数，就会调用拷贝构造函数
    Test t = getObj();
    cout << "t.m_num: " << *t.m_num << endl;
    return 0;
};
```

测试代码执行的结果如下（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）:

```c++
construct: my name is jerry
move construct: my name is sunny
destruct Test class ...
t.m_num: 100
destruct Test class ...
```

通过修改，在上面的代码给`Test`类添加了`移动构造函数（参数为右值引用类型）`，这样在进行`Test t = getObj();`操作的时候并没有调用拷贝构造函数进行深拷贝，而是调用了移动构造函数，在这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高了性能。

在测试程序中`getObj()`的返回值就是一个将亡值，也就是说是一个右值，在进行赋值操作的时候如果`=`右边是一个右值，那么移动构造函数就会被调用。`移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。`

> **==对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。==**

## 3.3 && 的特性

在C++中，并不是所有情况下 && 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为`T&&`，如果是自动类型推导需要指定为`auto &&`，在这两种场景下 &&被称作**未定的引用类型**。另外还有一点需要额外注意`const T&&`表示一个右值引用，不是未定引用类型。

先来看第一个例子，在函数模板中使用&&:

```c++
template<typename T>
void f(T&& param);
void f1(const T&& param);
f(10); 	
int x = 10;
f(x); 
f1(x);	// error, x是左值
f1(10); // ok, 10是右值
```

在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。

- 第4行中，对于`f(10)`来说传入的实参10是右值，因此`T&&`表示右值引用
- 第6行中，对于`f(x)`来说传入的实参是x是左值，因此`T&&`表示左值引用
- 第7行中，`f1(x)`的参数是`const T&&`不是未定引用类型，不需要推导，本身就表示一个右值引用

再来看第二个例子:

```c++
int main()
{
    int x = 520, y = 1314;
    auto&& v1 = x;
    auto&& v2 = 250;
    decltype(x)&& v3 = y;   // error
    cout << "v1: " << v1 << ", v2: " << v2 << endl;
    return 0;
};
```

- 第4行中 `auto&&`表示一个整形的左值引用
- 第5行中 `auto&&`表示一个整形的右值引用
- 第6行中`decltype(x)&&`等价于`int&&`是一个右值引用不是未定引用类型，y是一个左值，`不能使用左值初始化一个右值引用类型。`

由于上述代码中存在`T&&`或者`auto&&`这种未定引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型（&&）会发生变化，这种变化被称为引用折叠。在C++11中引用折叠的**==规则==**如下：

- ==**通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型**==
- ==**通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&& 或者 auto&& 得到的是一个左值引用类型**==

```c++
int&& a1 = 5;
auto&& bb = a1;
auto&& bb1 = 5;

int a2 = 5;
int &a3 = a2;
auto&& cc = a3;
auto&& cc1 = a2;

const int& s1 = 100;
const int&& s2 = 100;
auto&& dd = s1;
auto&& ee = s2;

const auto&& x = 5;
```

- 第2行：`a1`为右值引用，推导出的`bb`为`左值引用`类型
- 第3行：`5`为右值，推导出的`bb1`为`右值引用`类型
- 第7行：`a3`为左值引用，推导出的`cc`为`左值引用`类型
- 第8行：`a2`为左值，推导出的`cc1`为`左值引用`类型
- 第12行：`s1`为常量左值引用，推导出的`dd`为`常量左值引用`类型
- 第13行：`s2`为常量右值引用，推导出的`ee`为`常量左值引用`类型
- 第15行：`x`为右值引用，不需要推导，只能通过右值初始化

再看最后一个例子，代码如下：

```c++
#include <iostream>
using namespace std;

void printValue(int &i)
{
    cout << "l-value: " << i << endl;
}

void printValue(int &&i)
{
    cout << "r-value: " << i << endl;
}

void forward(int &&k)
{
    printValue(k);
}

int main()
{
    int i = 520;
    printValue(i);
    printValue(1314);
    forward(250);

    return 0;
};
```

测试代码输出的结果如下:

```c++
l-value: 520
r-value: 1314
l-value: 250
```

根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数forward()接收的是一个右值，但是在这个函数中调用函数printValue()时，参数k变成了一个命名对象，编译器会将其当做左值来处理。

最后总结一下关于&&的使用：

1. `左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。`
2. `编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。`
3. `auto&&或者函数参数类型自动推导的T&&是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。`
4. `通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型，其余都是左值引用类型。`

# 4、转移和完美转发

## 4.1 move

在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，`使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。`

从实现上讲，std::move基本等同于一个类型转换：`static_cast<T&&>(lvalue);`，函数原型如下:

```c++
template<class _Ty>
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) _NOEXCEPT
{	// forward _Arg as movable
    return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
}
```

使用方法如下：

```c++
class Test
{
public：
    Test(){}
    ......
}
int main()
{
    Test t;
    Test && v1 = t;          // error
    Test && v2 = move(t);    // ok
    return 0;
}
```

- 在第10行中，使用左值初始化右值引用，因此语法是错误的
- 在第11行中，使用`move()`函数将左值转换为了右值，这样就可以初始化右值引用了。

假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：

```c++
list<string> ls;
ls.push_back("hello");
ls.push_back("world");
......
list<string> ls1 = ls;        // 需要拷贝, 效率低
list<string> ls2 = move(ls);
```

如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（`T::T(T&& another)`）和和具有移动语义的赋值函数（`T&& T::operator=(T&& rhs)`），在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。

## 4.2 forward

右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用C++11提供的std::forward()函数，该函数实现的功能称之为**完美转发**。

```c++
// 函数原型
template <class T> T&& forward (typename remove_reference<T>::type& t) noexcept;
template <class T> T&& forward (typename remove_reference<T>::type&& t) noexcept;

// 精简之后的样子
std::forward<T>(t);
```

- `当T为左值引用类型时，t将被转换为T类型的左值`
- `当T不是左值引用类型时，t将被转换为T类型的右值`

下面通过一个例子演示一下关于forward的使用:

```c++
#include <iostream>
using namespace std;

// 这个函数模板接受一个左值引用（T&）。它会打印出一个左值，即传入的是一个命名的对象。
template<typename T>
void printValue(T& t)
{
    cout << "l-value: " << t << endl;
}

// 这个函数模板接受一个右值引用（T&&）。它会打印出一个右值，即传入的是临时对象或通过 move 转换的对象。
template<typename T>
void printValue(T&& t)
{
    cout << "r-value: " << t << endl;
}

template<typename T>
void testForward(T&& v)
{
    printValue(v);               // 传递原始参数 v
    printValue(move(v));         // 传递 v 的右值引用，强制转换为右值
    printValue(forward<T>(v));   // 完美转发 v，保持原有的值类别（左值或右值）
    cout << endl;
}

int main()
{
    testForward(520);                // 传入右值
    int num = 1314;
    testForward(num);                // 传入左值
    testForward(forward<int>(num));  // 完美转发 num，传入左值
    testForward(forward<int&>(num)); // 完美转发 num 的左值引用
    testForward(forward<int&&>(num));// 完美转发 num 的右值引用

    return 0;
}
```

测试代码打印的结果如下:

```c++
l-value: 520
r-value: 520
r-value: 520

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314
```

- `testForward(520);`函数的形参为**未定引用类型**`T&&`，实参为右值，初始化后被推导为一个右值引用
  - `printValue(v);`已命名的右值v，编译器会视为左值处理，实参为`左值`
  - `printValue(move(v));`已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为右值引用，最终得到一个右值，实参为``右值`
- `testForward(num);`函数的形参为**未定引用类型**`T&&`，实参为左值，初始化后被推导为一个左值引用
  - `printValue(v);`实参为`左值`
  - `printValue(move(v));`通过move将左值转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为左值引用，最终得到一个左值引用，实参为`左值`
- `testForward(forward<int>(num));` forward的模板类型为int，最终会得到一个右值，函数的形参为**未定引用类型**`T&&`被右值初始化后得到一个右值引用类型
  - `printValue(v);`已命名的右值v，编译器会视为左值处理，实参为`左值`
  - `printValue(move(v));`已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为右值引用，最终得到一个右值，实参为`右值`
- `testForward(forward<int&>(num));`forward的模板类型为int&，最终会得到一个左值，函数的形参为未定引用类型`T&&`被左值初始化后得到一个左值引用类型
  - `printValue(v);`实参为`左值`
  - `printValue(move(v));`通过move将左值转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为左值引用，最终得到一个左值，实参为`左值`
- `testForward(forward<int&&>(num));`forward的模板类型为int&&，最终会得到一个右值，函数的形参为未定引用类`T&&`被右值初始化后得到一个右值引用类型
  - `printValue(v);`已命名的右值v，编译器会视为左值处理，实参为`左值`
  - `printValue(move(v));`已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为`右值`
  - `printValue(forward<T>(v));`forward的模板参数为右值引用，最终得到一个右值，实参为`右值`

# 5、列表初始化

关于C++中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在C++11中提出了**列表初始化**的概念。

## 5.1 统一的初始化

在C++98/03中，对应普通数组和可以直接进行内存拷贝（memcpy()）的对象是可以使用列表初始化来初始化数据的

```c++
// 数组的初始化
int array[] = { 1,3,5,7,9 };
double array1[3] = { 1.2, 1.3, 1.4 };

// 对象的初始化
struct Person
{
    int id;
    double salary;
}zhang3{ 1, 3000 };
```

在C++11中，列表初始化变得更加灵活了，来看一下下面这段初始化类对象的代码：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test(int) {}
private:
    Test(const Test &);
};

int main(void)
{
    Test t1(520);
    Test t2 = 520;             // 错误
    Test t3 = { 520 };
    Test t4{ 520 };
    int a1 = { 1314 };
    int a2{ 1314 };
    int arr1[] = { 1, 2, 3 };
    int arr2[]{ 1, 2, 3 };
    return 0;
}
```

具体地来解读一下上面代码中使用的各种初始化方式：

- `t1`：最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化

- `t2`：语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，`520`会通过隐式类型转换被`Test(int)`构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到`t2`（**这个错误在VS中不会出现，在Linux中使用g++编译会提示描述的这个错误**，截图如下。）

  [![image-20210519095041852](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20210519095041852.png)](https://subingwen.cn/cpp/list-init/image-20210519095041852.png)

- `t3`和`t4`：使用了C++11的初始化方式来初始化对象，效果和`t1`的方式是相同的。
  - 在初始时，{}前面的等号是否书写对初始化行为没有任何影响。
  - `t3`虽然使`用了等号，但是它仍然是列表初始化`，因此私有的拷贝构造对它没有任何影响。
- `t1、arr1`和`t2、arr2`：这两个是基础数据类型的列表初始化方式，可以看到，和对象的初始化方式是统一的。
- `t4`、`a2`、`arr2`的写法，是C++11中新添加的语法格式，`使用这种方式可以直接在变量名后边跟上初始化列表，来进行变量或者对象的初始化。`

既然使用列表初始化可以对普通类型以及对象进行直接初始化，那么在使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化吗？答案是肯定的，来看下面的例子：

```c++
int * p = new int{520};
double b = double{52.134};
int * array = new int[3]{1,2,3};
```

- `指针p`指向了一个new操作符返回的内存，通过列表初始化将内存数据初始化为了520
- `变量b`是对匿名对象使用列表初始之后，再进行拷贝初始化。
- `数组array`在堆上动态分配了一块内存，通过列表初始化的方式直接完成了多个元素的初始化。

除此之外，列表初始化还可以直接用在函数返回值上：

```c++
#include <iostream>
#include <string>
using namespace std;

class Person
{
public:
    Person(int id, string name)
    {
        cout << "id: " << id << ", name: " << name << endl;
    }
};

Person func()
{
    return { 9527, "华安" };
}

int main(void)
{
    Person p = func();
    return 0;
}
```

代码中的`return { 9527, "华安" };`就相当于`return (9527, "华安" );`，直接返回了一个匿名对象。通过上面的几个例子可以看出在C++11使用列表初始化是非常便利的，它统一了各种对象的初始化方式，而且还让代码的书写更加简单清晰。

## 5.2 列表初始化细节

### 5.2.1 聚合体

在C++11中，列表初始化的使用范围被大大增强了，但是一些模糊的概念也随之而来，在前面的例子可以得知，列表初始化可以用于自定义类型的初始化，但是对于一个自定义类型，列表初始化可能有两种执行结果：

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    int y;
}a = { 123, 321 };

struct T2
{
    int x;
    int y;
    T2(int, int) : x(10), y(20) {}
}b = { 123, 321 };

int main(void)
{
    cout << "a.x: " << a.x << ", a.y: " << a.y << endl;
    cout << "b.x: " << b.x << ", b.y: " << b.y << endl;
    return 0;
}
```

程序执行的结果是这样的:

```c++
a.x: 123, a.y: 321
b.x: 10, b.y: 20
```

在上边的程序中都是用列表初始化的方式对对象进行了初始化，但是得到结果却不同，对象b并没有被初始化列表中的数据初始化，这是为什么呢？

- **对象a是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的成员。**
- **在结构体T2中自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的。**

现在很多小伙伴可能就一头雾水了，同样是自定义结构体并且在创建对象的时候都使用了列表初始化来初始化对象，为什么在类内部对对象的初始化方式却不一样呢？`因为如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是初始化列表中的数据就会拷贝到对象中。`

那么，使用列表初始化时，对于什么样的类型C++会认为它是一个**聚合体**呢？

- **普通数组本身可以看做是一个聚合类型**

  ```c++
  int x[] = {1,2,3,4,5,6};
  double y[3][3] = {
      {1.23, 2.34, 3.45},
      {4.56, 5.67, 6.78},
      {7.89, 8.91, 9.99},
  };
  char carry[] = {'a', 'b', 'c', 'd', 'e', 'f'};
  std::string sarry[] = {"hello", "world", "nihao", "shijie"};
  ```

- 满足以下条件的类（class、struct、union）可以被看做是一个**聚合类型**：

  - **无用户自定义的构造函数**。

  - **无私有或保护的非静态数据成员**。

    - 场景1: 类中有私有成员, 无法使用列表初始化进行初始化

      ```c++
      struct T1
      {
          int x;
          long y;
      protected:
          int z;
      }t{ 1, 100, 2};		// error, 类中有私有成员, 无法使用初始化列表初始化
      ```

    - 场景2：类中有非静态成员可以通过列表初始化进行初始化，但它不能初始化静态成员变量。

      ```c++
      struct T2
      {
          int x;
          long y;
      protected:
          static int z;
      }t{ 1, 100， 2};		// error
      ```

      结构体中的静态变量 z 不能使用列表初始化进行初始化，它的初始化遵循静态成员的初始化方式。

      ```c++
      struct T2
      {
          int x;
          long y;
      protected:
          static int z;
      }t{ 1, 100};		// ok
      // 静态成员的初始化
      int T2::z = 2;
      ```

  - 无基类。

  - 无虚函数。

  - 类中不能有使用`{}`和`=`直接初始化的非静态数据成员（从c++14开始就支持了）。

    ```c++
    #include <iostream>
    #include <string>
    using namespace std;
    
    struct T2
    {
        int x;
        long y;
    protected:
        static int z;
    }t1{ 1, 100 };		// ok
    // 静态成员的初始化
    int T2::z = 2;
    
    struct T3
    {
        int x;
        double y = 1.34;
        int z[3]{1,2,3};
    };
    
    int main(void)
    {
        T3 t{520, 13.14, {6,7,8}};		// error, c++11不支持,从c++14开始就支持了
        return 0;
    }
    ```

    > `从C++14开始，使用列表初始化也可以初始化在类中使用{}和=初始化过的非静态数据成员。`

### 5.2.2 非聚合体

对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，`需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:`

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    double y;
    // 在构造函数中使用初始化列表初始化类成员
    T1(int a, double b, int c) : x(a), y(b), z(c){}
    virtual void print()
    {
        cout << "x: " << x << ", y: " << y << ", z: " << z << endl;
    }
private:
    int z;
};

int main(void)
{
    T1 t{ 520, 13.14, 1314 };	// ok, 基于构造函数使用初始化列表初始化类成员
    t.print();
    return 0;
}
```

另外，需要额外注意的是`聚合类型的定义并非递归的`，也就是说`当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型`，比如下面的这个例子：

```c++
#include <iostream>
#include <string>
using namespace std;

// 非聚合体
struct T1
{
    int x;
    double y;
private:
    int z;
};

// 聚合体
struct T2
{
    T1 t1;
    long x1;
    double y1;
};

int main(void)
{
    T2 t2{ {}, 520, 13.14 };
    return 0;
}
```

可以看到，T1并非一个聚合类型，因为它有一个Private的非静态成员。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。

最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号`{}`，这相当于调用是T1的无参构造函数。

> **==对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数。==**

## 5.3 std::initializer_list

在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用`std::initializer_list`这个轻量级的类模板来实现。

先来介绍一下这个类模板的一些特点：

- 它是一个轻量级的容器类型，内部定义了迭代器`iterator`等容器必须的概念，`遍历时得到的迭代器是只读的。`
- 对于`std::initializer_list<T>`而言，它可以接收任意长度的初始化列表，但是要求**元素必须是同种类型T**
- 在`std::initializer_list`内部有三个成员接口：`size()`, `begin()`, `end()`。
- `std::initializer_list`对象只能被整体初始化或者赋值。

### 5.3.1 作为普通函数参数

如果想要自定义一个函数并且接收任意个数的参数（变参函数），只需要将函数参数指定为`std::initializer_list`，使用初始化列表`{ }`作为实参进行数据传递即可。

```c++
#include <iostream>
#include <string>
using namespace std;

void traversal(std::initializer_list<int> a)
{
    for (auto it = a.begin(); it != a.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main(void)
{
    initializer_list<int> list;
    cout << "current list size: " << list.size() << endl;
    traversal(list);

    list = { 1,2,3,4,5,6,7,8,9,0 };
    cout << "current list size: " << list.size() << endl;
    traversal(list);
    cout << endl;
    
    list = { 1,3,5,7,9 };
    cout << "current list size: " << list.size() << endl;
    traversal(list);
    cout << endl;

    ////////////////////////////////////////////////////
    ////////////// 直接通过初始化列表传递数据 //////////////
    ////////////////////////////////////////////////////
    traversal({ 2, 4, 6, 8, 0 });
    cout << endl;

    traversal({ 11,12,13,14,15,16 });
    cout << endl;


    return 0;
}
```

示例代码输出的结果：

```c++
current list size: 0

current list size: 10
1 2 3 4 5 6 7 8 9 0

current list size: 5
1 3 5 7 9

2 4 6 8 0

11 12 13 14 15 16
```

std::initializer_list拥有一个无参构造函数`，因此，它可以直接定义实例，此时将`得到一个空的std::initializer_list`，因为在遍历这种类型的容器的时候得到的是一个只读的迭代器，因此我们不能修改里边的数据，只能通过值覆盖的方式进行容器内部数据的修改。虽然如此，在效率方面也无需担心，`std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。

### 5.3.2 作为构造函数参数

自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为`std::initializer_list`类型，在自定义类的内部还是使用容器来存储接收的多个实参。

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Test
{
public:
    Test(std::initializer_list<string> list)
    {
        for (auto it = list.begin(); it != list.end(); ++it)
        {
            cout << *it << " ";
            m_names.push_back(*it);
        }
        cout << endl;
    }
private:
    vector<string> m_names;
};

int main(void)
{
    Test t({ "jack", "lucy", "tom" });
    Test t1({ "hello", "world", "nihao", "shijie" });
    return 0;
}
```

输出的结果:

```c++
jack lucy tom
hello world nihao shijie
```

# 6、using的使用

在C++中using用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在C++11中赋予了using新的功能，让C++变得更年轻，更灵活。

## 6.1 定义别名

在 C++中可以通过 **typedef** 重定义一个类型，语法格式如下：

```c++
typedef 旧的类型名 新的类型名;
// 使用举例
typedef unsigned int uint_t;
```

被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11中规定了一种新的方法，使用**别名声明(alias declaration)来定义类型的别名，即使用using**。

在使用的时候，关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。`类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。`

使用using定义别名的语法格式是这样的：

```c++
using 新的类型 = 旧的类型;
// 使用举例
using uint_t = int;
```

通过using和typedef的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了，看一下下面的例子：

```c++
// 使用typedef定义函数指针
typedef int(*func_ptr)(int, double);

// 使用using定义函数指针
using func_ptr1 = int(*)(int, double);
```

如果不是特别熟悉函数指针与typedef，第一眼很难看出func_ptr其实是一个别名，其本质是一个函数指针，指向的函数返回类型是int，函数参数有两个分别是int，double类型。

使用using定义函数指针别名的写法看起来就非常直观了，`把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边`，比较清晰，可读性比较好。

## 6.2 模板的别名

使用typedef重定义类似很方便，但是它有一点限制，比如无法重定义一个模板，比如我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:

```c++
typedef map<int, string> m1;
typedef map<int, int> m2;
typedef map<int, double> m3;
```

在这种情况下我们就不自觉的想到了模板：

```c++
template <typename T>
typedef map<int, T> type;	// error, 语法错误
```

使用typename不支持给模板定义别名，这个简单的需求仅通过typedef很难办到，需要添加一个**外敷类**：

```c++
#include <iostream>
#include <functional>
#include <map>
using namespace std;

template <typename T>
// 定义外敷类
struct MyMap
{
    typedef map<int, T> type;
};

int main(void)
{
    MyMap<string>::type m;
    m.insert(make_pair(1, "luffy"));
    m.insert(make_pair(2, "ace"));

    MyMap<int>::type m1;
    m1.insert(1, 100);
    m1.insert(2, 200);

    return 0;
}
```

通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。**在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名**，对于上面的需求可以写成这样：

```c++
template <typename T>
using mymap = map<int, T>;
```

完整的示例代码如下:

```c++
#include <iostream>
#include <functional>
#include <map>
using namespace std;

template <typename T>
using mymap = map<int, T>;

int main(void)
{
    // map的value指定为string类型
    mymap<string> m;
    m.insert(make_pair(1, "luffy"));
    m.insert(make_pair(2, "ace"));

    // map的value指定为int类型
    mymap<int> m1;
    m1.insert(1, 100);
    m1.insert(2, 200);

    return 0;
}
```

上面的例子中通过使用using给模板指定别名，就可以基于别名非常方便的给value指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。

**==最后在强调一点：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名==**。

# 7、可调用对象包装器、绑定器

## 7.1 可调用对象

在C++中存在“可调用对象”这么一个概念。准确来说，**可调用对象**有如下几种定义：

- `是一个函数指针`

  ```c++
  int print(int a, double b)
  {
      cout << a << b << endl;
      return 0;
  }
  // 定义函数指针
  int (*func)(int, double) = &print;
  ```

- `是一个具有operator()成员函数的类对象（仿函数，仿函数是一个类）`

  ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  
  struct Test
  {
      // ()操作符重载
      void operator()(string msg)
      {
          cout << "msg: " << msg << endl;
      }
  };
  
  int main(void)
  {
      Test t;
      t("我是要成为海贼王的男人!!!");	// 仿函数
      return 0;
  }
  ```

- `是一个可被转换为函数指针的类对象`

  ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  
  using func_ptr = void(*)(int, string);// 定义一个函数指针类型，指向 void(int, string) 函数
  
  struct Test
  {
      static void print(int a, string b)  // 类中的静态成员函数
      {
          cout << "name: " << b << ", age: " << a << endl;
      }
  
      // 将类对象转换为函数指针的操作符重载
      // 定义了一个类型转换操作符，将 Test 对象转换为类型为 func_ptr 的函数指针，指向 Test::print 函数
      operator func_ptr()  // 将 print 函数转换为 func_ptr 类型的函数指针
      {
          return print;  // 返回类中的静态函数指针
      }
  };
  
  int main(void)
  {
      Test t;
      // 对象转换为函数指针，并调用静态函数
      t(19, "Monkey D. Luffy");
      // Test 对象 t 没有直接重载 operator()，但是通过类型转换操作符 operator func_ptr()，Test 对象 t 被转换为 func_ptr 类型。
      // func_ptr 是一个指向 void print(int, string) 的函数指针，所以 t(19, "Monkey D. Luffy") 相当于 print(19, "Monkey D. Luffy")，即调用了 Test::print 函数。
  
      return 0;
  }
  ```

  #### 类型转换操作符

  C++ 允许你在类中定义 **类型转换操作符**，以便将类的对象转换为其他类型。这种操作符的语法如下：

  ```c++
  operator target_type();
  ```

  - `target_type` 是你想要转换成的目标类型。比如在你的代码中，`target_type` 是 `func_ptr`（一个函数指针类型）。
  - `operator func_ptr()` 表示将 `Test` 类型的对象转换为 `func_ptr` 类型。

- `是一个类成员函数指针或者类成员指针`

  ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  using namespace std;
  
  struct Test
  {
      void print(int a, string b)
      {
          cout << "name: " << b << ", age: " << a << endl;
      }
      int m_num;
  };
  
  int main(void)
  {
      // 定义类成员函数指针指向类成员函数
      void (Test::*func_ptr)(int, string) = &Test::print;
      // 类成员指针指向类成员变量
      int Test::*obj_ptr = &Test::m_num;
  
      Test t;
      // 通过类成员函数指针调用类成员函数
      (t.*func_ptr)(19, "Monkey D. Luffy");
      // 通过类成员指针初始化类成员变量
      t.*obj_ptr = 1;
      cout << "number is: " << t.m_num << endl;
  
      return 0;
  }
  ```

在上面的例子中满足条件的这些可调用对象对应的类型被统称为`可调用类型`。C++中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，`C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。`

## 7.2 可调用对象包装器

**==std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类(非静态)成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们==**。

### 7.2.1 基本用法

std::function必须要包含一个叫做`functional`的头文件，可调用对象包装器使用语法如下:

```c++
#include <functional>
std::function<返回值类型(参数类型列表)> diy_name = 可调用对象;
```

下面的实例代码中演示了可调用对象包装器的基本使用方法：

```c++
#include <iostream>
#include <functional>
using namespace std;

int add(int a, int b)
{
    cout << a << " + " << b << " = " << a + b << endl;
    return a + b;
}

class T1
{
public:
    static int sub(int a, int b)
    {
        cout << a << " - " << b << " = " << a - b << endl;
        return a - b;
    }
};

class T2
{
public:
    int operator()(int a, int b)
    {
        cout << a << " * " << b << " = " << a * b << endl;
        return a * b;
    }
};

int main(void)
{
    // 绑定一个普通函数
    function<int(int, int)> f1 = add;
    // 绑定一个静态类成员函数
    function<int(int, int)> f2 = T1::sub;
    // 绑定一个仿函数
    T2 t;
    function<int(int, int)> f3 = t;

    // 函数调用
    f1(9, 3);
    f2(9, 3);
    f3(9, 3);

    return 0;
}
```

输入结果如下:

```c++
9 + 3 = 12
9 - 3 = 6
9 * 3 = 27
```

**==通过测试代码可以得到结论：std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了==**。

### 7.2.2 作为回调函数使用

因为回调函数本身就是通过函数指针实现的，`使用对象包装器可以取代函数指针的作用`，来看一下下面的例子：

```c++
#include <iostream>
#include <functional>
using namespace std;

class A
{
public:
    // 构造函数参数是一个包装器对象
    A(const function<void()>& f) : callback(f)
    {
    }

    void notify()
    {
        callback(); // 调用通过构造函数得到的函数指针
    }
private:
    function<void()> callback;  // 存储传入的回调函数
};

class B
{
public:
    void operator()()
    {
        cout << "我是要成为海贼王的男人!!!" << endl;
    }
};
int main(void)
{
    // 在 main 函数中，首先创建了 B 类的对象 b。
	// 然后创建了 A 类的对象 a，并将 b 作为参数传递给 A 类的构造函数。
	// 在 A 类的构造函数中，b 被包装进了一个 std::function<void()> 对象 callback 中。
	// 最后，调用 a.notify()，这会触发 callback()，即调用 B::operator()，输出 "我是要成为海贼王的男人!!!"。
    B b;
    A a(b); // 仿函数通过包装器对象进行包装
    a.notify();

    return 0;
}
```

通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。

另外，使用std::function作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。

## 7.3 绑定器

`std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候`。通俗来讲，它主要有两大作用：

1. `将可调用对象与其参数一起绑定成一个仿函数。`**==(仿函数)==**
2. `将多元（参数个数为n，n>1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。`

绑定器函数使用语法格式如下：

```c++
// 绑定非类成员函数/变量
auto f = std::bind(可调用对象地址, 绑定的参数/占位符);
// 绑定类成员函/变量
auto f = std::bind(类 函数/成员 地址, 类实例对象地址, 绑定的参数/占位符);
```

下面来看一个关于绑定器的实际使用的例子：

```c++
#include <iostream>
#include <functional>
using namespace std;

void callFunc(int x, const function<void(int)>& f)
{
    if (x % 2 == 0)
    {
        f(x);
    }
}

void output(int x)
{
    cout << x << " ";
}

void output_add(int x)
{
    cout << x + 10 << " ";
}

int main(void)
{
    // 使用绑定器绑定可调用对象和参数
    auto f1 = bind(output, placeholders::_1);
    for (int i = 0; i < 10; ++i)
    {
        callFunc(i, f1);  // 0 2 4 6 8
    }
    cout << endl;


    for (int i = 0; i < 10; ++i)
    {
        auto f3 = bind(output, i + 100);
        // !!!上面绑定的时候，不是占位符，所以下面callFunc(i, f3);中的i不生效
        callFunc(i, f3);  // 100 102 104 106 108
    }
    cout << endl;


    auto f2 = bind(output_add, placeholders::_1);
    for (int i = 0; i < 10; ++i)
    {
        callFunc(i, f2);  // 10 12 14 16 18
    }
    cout << endl;

    return 0;
}
```

测试代码输出的结果:

```c++
0 2 4 6 8
100 102 104 106 108
10 12 14 16 18
```

在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。`std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。`

`placeholders::_1`是一个占位符，`代表这个位置将在函数调用时被传入的第一个参数所替代`。同样还有其他的占位符`placeholders::_2`、`placeholders::_3`、`placeholders::_4`、`placeholders::_5`等……

有了占位符的概念之后，使得std::bind的使用变得非常灵活:

```c++
#include <iostream>
#include <functional>
using namespace std;

void output(int x, int y)
{
    cout << x << " " << y << endl;
}

int main(void)
{
    // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数
    bind(output, 1, 2)();  // 1 2
    bind(output, placeholders::_1, 2)(10);  // 10 2
    bind(output, 2, placeholders::_1)(10);  // 2 10

    // error, 调用时没有第二个参数
    // bind(output, 2, placeholders::_2)(10);
    // 调用时第一个参数10被吞掉了，没有被使用
    bind(output, 2, placeholders::_2)(10, 20); // 2, 20。10不起作用

    bind(output, placeholders::_1, placeholders::_2)(10, 20); // 10 20
    bind(output, placeholders::_2, placeholders::_1)(10, 20); // 20 10


    return 0;
}
```

示例代码执行的结果:

```c++
1 2		    // bind(output, 1, 2)();
10 2		// bind(output, placeholders::_1, 2)(10);
2 10		// bind(output, 2, placeholders::_1)(10);
2 20		// bind(output, 2, placeholders::_2)(10, 20);
10 20		// bind(output, placeholders::_1, placeholders::_2)(10, 20);
20 10		// bind(output, placeholders::_2, placeholders::_1)(10, 20);
```

通过测试可以看到，std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。

**可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的**，但是通过绑定器std::bind的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：

```c++
// 绑定类成员函/变量  
// 语法格式：
auto f = std::bind(类 函数 / 成员 地址, 类实例对象地址, 绑定的参数 / 占位符);

#include <iostream>
#include <functional>
using namespace std;

class Test
{
public:
    void output(int x, int y)
    {
        cout << "x: " << x << ", y: " << y << endl;
    }
    int m_number = 100;
};

int main(void)
{
    Test t;
    // 绑定类成员函数
    auto f1 = bind(&Test::output, &t, 520, placeholders::_1);
    function<void(int, int)> f11 = 
        bind(&Test::output, &t, placeholders::_1, placeholders::_2);
    // 绑定类成员变量(公共)
    auto f2 = bind(&Test::m_number, &t);
    function<int& (void)> f22 = bind(&Test::m_number, &t);

    // 调用
    f1(1314);              // x: 520, y: 1314
    cout << f2() << endl;  // 100
    f2() = 666;        
    cout << f2() << endl;  // 666

    f11(520, 1314);        // x: 520, y: 1314
    f22() = 2333;
    cout << "t.m_number: " << t.m_number << endl;  // t.m_number: 2333

    return 0;
}
```

示例代码输出的结果:

```c++
x: 520, y: 1314
100
666
x: 520, y: 1314
t.m_number: 2333
```

在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。`f11的类型是function<void(int, int)>，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f11中。`

**==使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function<int&(void)>的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void==**。

示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。

# 8、POD类型

## 8.1 POD 类型

**POD**是英文中 **Plain Old Data** 的缩写，翻译过来就是**普通的旧数据** 。POD在C++中是非常重要的一个概念，`通常用于说明一个类型的属性，尤其是用户自定义类型的属性。`

POD属性在C++11中往往又是构建其他C++概念的基础，事实上，在C++11标准中，POD出现的概率相当高。因此学习C++，尤其是在 C++11中，了解 POD的概念是非常必要的。

1. **Plain** ：表示是个普通的类型
2. **Old** ：体现了其与C的兼容性，支持标准C函数

在C++11中将 POD划分为两个基本概念的合集，即∶**平凡的（trivial）** 和**标准布局的（standard layout ）** 。 

## 8.2 “平凡”类型

一个平凡的类或者结构体应该符合以下几点要求：

1. **拥有平凡的默认构造函数（trivial constructor）和析构函数（trivial destructor）。**

   平凡的默认构造函数就是说构造函数`什么都不干`。

   - 通常情况下，`不定义类的构造函数`，编译器就会为我们`生成一个平凡的默认构造函数`。

     ```c++
     // 使用默认的构造函数
     class Test {};
     ```

   - `一旦定义了构造函数`，即使构造函数不包含参数，函数体里也没有任何的代码，`那么该构造函数也不再是"平凡"的`。

     ```C++
     class Test1 
     {
         Test1();	// 程序猿定义的构造函数, 非默认构造
     };
     ```

     关于析构函数也和上面列举的构造函数类似，一旦被定义就不平凡了。但是这也并非无药可救，使用 **==9.2.1 =default关键字==** 可以显式地声明默认的构造函数，从而使得类型恢复 “平凡化”。

2. **拥有平凡的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）。**

   - 平凡的拷贝构造函数基本上等同于使用memcpy 进行类型的构造。
   - 同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。
   - 可以显式地使用=default 声明默认拷贝构造函数。 
   - 而平凡移动构造函数跟平凡的拷贝构造函数类似，只不过是用于移动语义。

3. **拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）。**

   这基本上与平凡的拷贝构造函数和平凡的移动构造运算符类似。

4. **不包含虚函数以及虚基类。**

   - 类中使用 **==virtual 关键字修饰的函数==** 叫做 **==虚函数==**

     ```c++
     class Base 
     {
     public:
         Base() {}
         virtual void print() {}
     };
     ```

   - **==虚基类==** 是在**==创建子类的时候在继承的基类前加virtual 关键字==** 修饰

     ```c++
     语法: class 派生类名：virtual  继承方式  基类名
     ```

     示例代码：

     ```c++
     class Base 
     {
     public:
         Base() {}
     };
     // 子类Child，虚基类：Base
     class Child : virtual public Base 
     {
         Child() {}
     };
     ```

## 8.3 “标准布局”类型

标准布局类型主要主要指的是`类`或者`结构体`的结构或者组合方式。

标准布局类型的类应该符合以下五点定义，`最重要的为前两条`：

1. **所有非静态成员有 ==相同== 的访问权限（public，private，protected）。**

   - 类成员拥有不同的访问权限（`非标准布局类型`）

     ```c++
     class Base
     {
     public:
         Base() {}
         int a;
     protected:
         int b;
     private:
         int c;
     };
     ```

   - 类成员拥有相同的访问权限（`标准布局类型`）

     ```c++
     class Base
     {
     public:
         Base() {}
         int a;
         int b;
         int c;
     };
     ```

2. **在类或者结构体继承时，满足以下两种情况之一∶** 

   - **派生类中有非静态成员，基类中包含静态成员（或基类没有变量）。**
   - **基类有非静态成员，而派生类没有非静态成员。**

   ```c++
   struct Base { static int a;};
   struct Child: public Base{ int b;};          // ok
   struct Base1 { int a;};
   struct Child1: public Base1{ static int c;}; // ok
   struct Child2:public Base, public Base1 { static int d;); // ok
   struct Child3:public Base1{ int d;};         // error
   struct Child4:public Base1, public Child     // error
   {
       static int num;
   };
   ```

   > 通过上述例子得到的结论：
   >
   > 1. `非静态成员只要同时出现在派生类和基类间，即不属于标准布局。`
   > 2. `对于多重继承，一旦非静态成员出现在多个基类中，即使派生类中没有非静态成员变量，派生类也不属于标准布局。`

3. **子类中第一个非静态成员的类型与其基类不同。** 

   **==此处基于G++编译器讲解，如果使用VS的编译器和G++编译器得到的结果是不一样的。==**

   ```c++
   struct Parent{};
   struct Child : public Parent
   {
       Parent p;	// 子类的第一个非静态成员
       int foo;
   };
   ```

   上面的例子中`Child`不是一个标准布局类型，因为它的第一个非静态成员变量`p`和父类的类型相同，改成下面这样子类就变成了一个标准布局类型：

   ```c++
   struct Parent{};
   struct Child1 : public Parent
   {
       int foo;   // 子类的第一个非静态成员
       Parent p;	
   };
   ```

   这条规则对于我们来说是比较特别的，这样规定的目的主要是是节约内存，提高数据的读取效率。对于上面的两个子类`Child`和`Child1`来说它们的内存结构是不一样的，**==在基类没有成员的情况下==**：

   - C++标准允许`标准布局类型（Child1）`派生类的第一个`成员foo与基类共享地址`，此时基类并没有占据任何的实际空间（可以节省一点数据）

   - 对于子类`Child`而言，如果子类的第一个成员仍然是基类类型，C++标准要求类型相同的对象它们的地址必须不同（`基类地址不能和子类中的变量 p 类型相同`），此时需要分配额外的地址空间将二者的地址错开。

     ![image-20211216174452356](C++11%E6%96%B0%E7%89%B9%E6%80%A7.assets/image-20211216174452356.png)

4. **没有虚函数和虚基类。** 

5. **所有非静态数据成员均符合标准布局类型，其基类也符合标准布局，这是一个递归的定义。**

## 8.4 对 POD 类型的判断

如果我们想要判断某个数据类型是不是属于 POD 类型，可以使用C++11给我们提供的相关函数：

### 8.4.1 对“平凡”类型判断

C++11提供的类模板叫做 `is_trivial`，其定义如下：

```c++
template <class T> struct std::is_trivial;
```

`std::is_trivial `的成员`value` 可以用于判断T的类型是否是一个平凡的类型（`value 函数返回值为布尔类型`）。除了类和结构体外，`is_trivial`还可以对内置的标准类型数据（比如int、float都属于平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。

关于类型的判断，示例程序如下：

```c++
#include <iostream>
#include <type_traits>
using namespace std;

class A {};
class B { B() {} };
class C : B {};
class D { virtual void fn() {} };
class E : virtual public A { };

int main() 
{
    cout << std::boolalpha;
    cout << "is_trivial:" << std::endl;
    cout << "int: " << is_trivial<int>::value << endl;
    cout << "A: " << is_trivial<A>::value << endl;
    cout << "B: " << is_trivial<B>::value << endl;
    cout << "C: " << is_trivial<C>::value << endl;
    cout << "D: " << is_trivial<D>::value << endl;
    cout << "E: " << is_trivial<E>::value << endl;
    return 0;
}
```

输出的结果：

```c++
is_trivial:
int: true
A: true
B: false
C: false
D: false
E: false
```

- **int** ：内置标准数据类型，属于 trivial 类型
- **A** ：拥有默认的构造和析构函数，属于 trivial 类型
- **B** ：自定义了构造函数，因此不属于 trivial 类型
- **C** ：基类中自定义了构造函数，因此不属于 trivial 类型
- **D** ：类成员函数中有虚函数，因此不属于 trivial 类型
- **E** ：继承关系中有虚基类，因此不属于 trivial 类型

### 8.4.2 对“标准布局”类型的判断

同样，在C++11中，我们可以使用模板类来帮助判断类型是否是一个标准布局的类型，其定义如下：

```c++
template <typename T> struct std::is_standard_layout;
```

通过 `is_standard_layout`模板类的成员 `value（is_standard_layout<T>∶∶value）`，我们可以在代码中打印出类型的标准布局属性，函数返回值为布尔类型。

#### 示例程序

关于类型的判断，示例程序如下：

```c++
// pod.cpp
#include <iostream>
#include <type_traits>
using namespace std;

struct A { };
struct B : A { int j; };
struct C
{
public:
    int a;
private:
    int c;
};
struct D1 {  static int i; };
struct D2 {  int i; };
struct E1 { static int i; };
struct E2 { int i; };
struct D : public D1, public E1 { int a; };
struct E : public D1, public E2 { int a; };
struct F : public D2, public E2 { static int a; };
struct G : public A
{
    int foo;
    A a;
};
struct H : public A
{
    A a;
    int foo;
};

int main() 
{
    cout << std::boolalpha;
    cout << "is_standard_layout:" << std::endl;
    cout << "A: " << is_standard_layout<A>::value << endl;
    cout << "B: " << is_standard_layout<B>::value << endl;
    cout << "C: " << is_standard_layout<C>::value << endl;
    cout << "D: " << is_standard_layout<D>::value << endl;
    cout << "D1: " << is_standard_layout<D1>::value << endl;
    cout << "E: " << is_standard_layout<E>::value << endl;
    cout << "F: " << is_standard_layout<F>::value << endl;
    cout << "G: " << is_standard_layout<G>::value << endl;
    cout << "H: " << is_standard_layout<H>::value << endl;
    return 0;
}
```

#### VS2019输出的结果

```c++
is_standard_layout:
A: true
B: true
C: false
D: true
D1: true
E: false
F: false
G: false
H: false
```

#### G++ 编译输出的结果:

- 编译命令

  ```shell
  $ g++ pod.cpp -std=c++11
  ```

- 输出的结果

  ```c++
  is_standard_layout:
  A: true
  B: true
  C: false
  D: true
  D1: true
  E: false
  F: false
  G: true
  H: false
  ```

#### 关于输出的结果

- **A** ：没有虚基类和虚函数，属于 standard_layout 类型
- **B** ：没有虚基类和虚函数，属于 standard_layout 类型
- **C** ：所有非静态成员访问权限不一致，不属于 standard_layout 类型
- **D** ：基类和子类没有同时出现非静态成员变量，属于 standard_layout 类型
- **D1** ：没有虚基类和虚函数，属于 standard_layout 类型
- **E** ：基类和子类中同时出现了非静态成员变量，不属于 standard_layout 类型
- **F** ：多重继承中在基类里同时出现了非静态成员变量，不属于 standard_layout 类型
- **G** ：使用的编译器不同，得到的结果也不同。
- **H** ：子类中第一个非静态成员的类型与其基类类型不能相同，不属于 standard_layout 类型

## 8.5 总结

事实上，我们使用的很多内置类型默认都是 POD的。POD 最为复杂的地方还是在类或者结构体的判断。不过上面也给大家介绍了判断的方法，相信大家对 POD已经有所理解。那么，使用POD有什么好处呢？

1. 字节赋值，代码中我们可以安全地使用memset 和 memcpy 对 POD类型进行初始化和拷贝等操作。 
2. 提供对C内存布局兼容。C++程序可以与C 函数进行相互操作，因为POD类型的数据在C与C++ 间的操作总是安全的。 
3. 保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单。

 

关于 POD 重在理解，我们在查阅资料的时候经常会看到引用POD的地方，所以建议大家花时间消化一下这个概念。 

# 9、默认函数控制 =default 与 =delete

## 9.1 类与默认函数

在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未自定义的成员函数。这样的函数版本被称为”**默认函数**”。这样的函数一共有六个，我们一起来看一下：

1. `无参构造函数`：创建类对象
2. `拷贝构造函数`：拷贝类对象
3. `移动构造函数`：拷贝类对象
4. `拷贝赋值函数`：类对象赋值
5. `移动赋值函数`：类对象赋值
6. `析构函数 `：销毁类对象

**==在C++语法规则中，一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本==**。

有时程序员会忘记上面提到的规则，最常见的是声明了带参数的构造，如果还需要无参构造函数，这时候必须定义出不带参数的版本。不过通过编译器的提示，这样的问题通常会得到更正。但更为严重的问题是，一旦声明了自定义版本的构造函数，则有可能导致我们定义的类型不再是**POD类型**，见8，我们便不再能够享受POD类型为我们带来的便利。

对于上面提到的这些，我们无需过度担心，因为C++11非常贴心地为我们提供了解决方案，就是使用**===default==** 。

## 9.2 =default 和 =delete

在C++11标准中称`= default`修饰的函数为`显式默认【缺省】（explicit defaulted）函数`，而称`=delete`修饰的函数为`删除（deleted）函数或者显示删除函数`。

 C++11引入显式默认和显式删除是为了增强对类默认函数的控制，让程序员能够更加精细地控制默认版本的函数。

### 9.2.1 =default

我们可以在类内部修饰满足条件的类函数为显示默认函数，也可以在类定义之外修饰成员函数为默认函数。下面举例说明：

#### **在类内部指定函数为默认函数**

一般情况下，我们可以在定义类的时候直接在类内部指定默认函数，如下所示：

```c++
class Base
{
public:
    Base() = default;
    Base(const Base& obj) = default;
    Base(Base&& obj) = default;
    Base& operator= (const Base& obj) = default;
    Base& operator= (Base&& obj) = default;
    ~Base() = default;
};
```

- 第4行：指定无参构造为默认函数
- 第5行：指定拷贝构造函数为默认函数
- 第6行：指定移动构造函数为默认函数
- 第7行：指定复制赋值操作符重载函数为默认函数
- 第8行：指定移动赋值操作符重载函数为默认函数
- 第9行：指定析构函数为默认函数

使用 =defaut 指定的默认函数和类提供的默认函数是等价的

#### **在类外部指定函数为默认函数**

默认函数除了在类定义的内部指定，也可以在类的外部指定，如下所示：

```c++
// 类定义
class Base
{
public:
    Base();
    Base(const Base& obj);
    Base(Base&& obj);
    Base& operator= (const Base& obj);
    Base& operator= (Base&& obj);
    ~Base();
};
// 在类定义之外指定成员函数为默认函数
Base::Base() = default;
Base::Base(const Base& obj) = default;
Base::Base(Base&& obj) = default;
Base& Base::operator= (const Base& obj) = default;
Base& Base::operator= (Base&& obj) = default;
Base::~Base() = default;
```

#### **定义默认函数的注意事项:**

如果程序猿对C++类提供的默认函数（上面提到的六个函数）进行了实现，那么可以通过 =default 将他们再次指定为默认函数，**不能使用 =default 修饰这六个函数以外的函数**。

```c++
class Base
{
public:
    Base() = default;
    Base(const Base& obj) = default;
    Base(Base&& obj) = default;
    Base& operator= (const Base& obj) = default;
    Base& operator= (Base&& obj) = default;
    ~Base() = default;

    // 以下写法全部都是错误的
    Base(int a = 0) = default;
    Base(int a, int b) = default;
    void print() = default;
    bool operator== (const Base& obj) = default;
    bool operator>=(const Base& obj) = default;
};
```

- 第12行：自定义带参构造，不允许使用 `=default` 修饰（即使有默认参数也不行）
- 第13行：自定义带参构造，不允许使用 `=default` 修饰
- 第14行：自定义函数，不允许使用 `=default` 修饰
- 第15、16行：不是移动、复制赋值运算符重载，不允许使用 `=default` 修饰

### 9.2.2 =delete

=delete 表示**显示删除**，`显式删除可以避免用户使用一些不应该使用的类的成员函数`，使用这种方式可以有效的防止某些类型之间自动进行隐式类型转换产生的错误。下面举例说明：

#### **禁止使用默认生成的函数**

```c++
class Base
{
public:
    Base() = default;
    Base(const Base& obj) = delete;
    Base& operator= (const Base& obj) = delete;
};

int main()
{
    Base b;
    Base tmp1(b);    // error
    Base tmp = b;    // error
    return 0;
}
```

- 第5行：禁用拷贝构造函数
- 第6行：禁用 = 进行对象复制
- 第12行：拷贝构造函数已被显示删除，无法拷贝对象
- 第13行：复制对象的赋值操作符重载函数已被显示删除，无法复制对象

#### **禁止使用自定义函数**

```c++
class Base
{
public:
    Base(int num) : m_num(num) {}
    Base(char c) = delete;
    void print(char c) = delete;
    void print()
    {
        cout << "num: " << m_num << endl;
    }
    void print(int num)
    {
        cout << "num: " << num << endl;
    }
private:
    int m_num;
};

int main()
{
    Base b(97);       // 'a' 对应的 acscii 值为97
    Base b1('a');     // error
    b.print();
    b.print(97);
    b.print('a');     // error
    return 0;
}
```

- 第5行：禁用带 `char`类型参数的构造函数，防止隐式类型转换（char转int)
- 第6行：禁止使用带`char`类型的自定义函数，防止隐式类型转换（char转int)
- 第22行：对应的构造函数被禁用，因此无法使用该构造函数构造对象
- 第25行：对应的打印函数被禁用，因此无法给函数传递`char`类型参数

# 10、扩展到 friend 语法

`friend`关键字在C++中是一个比较特别的存在。因为在大多数编程语言中是没有提供`friend`关键字的，比如Java。friend关键字用于声明类的友元，友元可以无视类中成员的属性（ public、protected 或是 private ），友元类或友元函数都可以访问，这就`完全破坏了面向对象编程中封装性的概念`。但有的时候，friend关键字确实会让程序猿少写很多代码，因此 friend 还是在很多程序中被使用到。

## 10.1 语法改进

在 C++11 标准中对 friend关键字进行了一些改进，以保证其更加好用：

**==声明一个类为另外一个类的友元时，不再需要使用class关键字，并且还可以使用类的别名（使用 typedef 或者 using 定义）==**。

我们可以看看下面的例子：

```c++
#include <iostream>
using namespace std;

// 类声明
class Tom;
// 定义别名
using Honey = Tom;

// 定义两个测试类
class Jack
{
    // 声明友元
    // friend class Tom;    // C++98 标准语法
    friend Tom;             // C++11 标准语法 
    string name = "jack";   // 默认私有
    void print()            // 默认私有
    {
        cout << "my name is " << name << endl;
    }
};

class Lucy
{
protected:
    // 声明友元
    // friend class Tom;    // C++98 标准语法
    friend Honey;           // C++11 标准语法 
    string name = "lucy";
    void print()
    {
        cout << "my name is " << name << endl;
    }
};

class Tom
{
public:
    void print()
    {
        // 通过类成员对象访问其私有成员
        cout << "invoke Jack private member: " << jObj.name << endl;
        cout << "invoke Jack private function: " << endl;
        jObj.print();

        cout << "invoke Lucy private member: " << lObj.name << endl;
        cout << "invoke Lucy private function: " << endl;
        lObj.print();
    }
private:
    string name = "tom";
    Jack jObj;
    Lucy lObj;
};

int main()
{
    Tom t;
    t.print();
    return 0;
}
```

在上面的例子中 `Tom 类`分别作为了`Jack类`和`Lucy类`的友元类，然后在`Tom类`中定义了`Jack类`和`Lucy类`的对象`jObj`和`lObj`，这样我们就可以在`Tom类`中通过这两个类对象直接访问它们各自的私有或者受保护的成员变量或者成员函数了。

## 10.2 为类模板声明友元

虽然在C++11标准中对友元的改进不大，却会带来应用的变化——程序员**可以为类模板声明友元了**，这在C++98中是无法做到的。使用方法如下：

```c++
class Tom;

template<typename T>  
class Person
{
    friend T;
};

int main()
{
    Person<Tom> p;
    Person<int> pp;
    return 0;
}
```

- 第11行：`Tom类`是`Person类`的友元
- 第12行：对于`int`类型的模板参数，友元声明被忽略（第6行）

这样一来，我们就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元。

下面基于一个实际场景来讲解一下如何给模板类指定友元：

假设有一个矩形类，一个圆形类，我们在对其进行了一系列的操作之后，需要验证一下矩形的宽度和高度、圆形的半径是否满足要求，并且要求这个校验操作要在另一个类中完成。

```c++
template<typename T>  
class Rectangle
{
public:
    friend T;
    Rectangle(int w, int h) : width(w), height(h) {}
private:
    int width;
    int height;
};

template<typename T> 
class Circle
{
public:
    friend T;
    Circle(int r) : radius(r) {}
private:
    int radius;
};

// 校验类
class Verify
{
public:
    void verifyRectangle(int w, int h, Rectangle<Verify> &r)
    {
        if (r.width >= w && r.height >= h) // 在Verify类中 访问了 Rectangle类 的私有成员变量
        {
            cout << "矩形的宽度和高度满足条件!" << endl;
        }
        else
        {
            cout << "矩形的宽度和高度不满足条件!" << endl;
        }
    }

    void verifyCircle(int r, Circle<Verify> &c)
    {
        if (r >= c.radius)  // 第40行：在`Verify类`中 访问了 `Circle类` 的私有成员变量
        {
            cout << "圆形的半径满足条件!" << endl;
        }
        else
        {
            cout << "圆形的半径不满足条件!" << endl;
        }
    }
};

int main()
{
    Verify v;
    Circle<Verify> circle(30);
    Rectangle<Verify> rect(90, 100);
    v.verifyCircle(60, circle);
    v.verifyRectangle(100, 100, rect);
    return 0;
}
```

- 第28行：在`Verify类`中 访问了 `Rectangle类` 的私有成员变量
- 第40行：在`Verify类`中 访问了 `Circle类` 的私有成员变量

程序输出的结果：

```c++
圆形的半径满足条件!
矩形的宽度和高度不满足条件!
```

在上面的例子中我们定义了两个类模板`Rectangle`和`Circle`并且将其模板类型定义为了它们的友元（如果是模板类型是基础类型友元的定义就被忽略了）。在`main()函数`中测试的时候将`Verify`类指定为了两个模板类的实际友元类型。这样我们在`Verify`类中就可以通过`Rectangle类`和`Circle类`的实例对象访问它们内部的私有成员变量了。

补充说明：

1. 在上面的测试程序中`Rectangle类`和`Circle类`我们没有提供对应的`set方法`来设置私有成员的值，为了简化程序直接通过构造函数的初始化列表完成了它们的初始化。
2. 在上面的程序中也没有给`Rectangle类`和`Circle类`提供`get方法`，这样如果想要在类外部访问私有（或受保护）成员就只能使用友元了（此处这样处理完全了为了测试的需要）。

# 11、强类型枚举

## 11.1 枚举

### 11.1.1 枚举的使用

枚举类型是C及C++中一个基本的内置类型，不过也是一个有点”奇怪”的类型。从枚举的本意上来讲，就是要定义一个类别，并穷举同一类别下的个体以供代码中使用。由于枚举来源于C，所以出于设计上的简单的目的，枚举值常常是对应到整型数值的一些名字，比如：

```c++
// 匿名枚举
enum {Red, Green, Blue};
// 有名枚举
enum Colors{Red, Green, Blue};
```

在枚举类型中的枚举值编译器会默认从0开始赋值，而后依次向下递增，也就是说`Red=0，Green=1，Blue=2`。

### 11.1.2 枚举的缺陷

C/C++的enum有个很”奇怪” 的设定，就是`具名（有名字）的enum类型的名字，以及 enum 的成员的名字都是全局可见的`。这与 C++中具名的 namespace、class/struct 及 union 必须通过`名字::成员名`的方式访问相比是格格不入的，编码过程中一不小心程序员就容易遇到问题。比如∶

```c++
enum China {Shanghai, Dongjing, Beijing, Nanjing};
enum Japan {Dongjing, Daban, Hengbin, Fudao};
```

上面定义的两个枚举在编译的时候，编译器会报错，具体信息如下：

```c++
error C2365: “Dongjing”: 重定义；以前的定义是“枚举数”
```

错误的原因上面也提到了，在这两个具名的枚举中`Dongjing`是全局可见的，所有编译器就会提示其重定义了。

另外，由于C中枚举被设计为常量数值的”别名”的本性，所以**枚举的成员总是可以被隐式地转换为整型**，但是很多时候我们并不想这样。

## 11.2 强类型枚举

### 11.2.1 优势

针对枚举的缺陷，C++11标准引入了一种新的枚举类型，即`枚举类`，又称`强类型枚举（strong-typed enum）`。 声明强类型枚举非常简单，`只需要在 enum 后加上关键字 class。`比如∶

```c++
// 定义强类型枚举
enum class Colors{Red, Green, Blue};
```

强类型枚举具有以下几点优势∶ 

- 强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。

  - 强类型枚举只能是有名枚举，如果是匿名枚举会导致枚举值无法使用（因为没有作用域名称）。

- 转换限制，强类型枚举成员的值不可以与整型隐式地相互转换。 

- 可以指定底层类型。强类型枚举默认的底层类型为 int，但也可以显式地指定底层类型， 具体方法为在枚举名称后面加上`∶type`，其中 `type 可以是除 wchar_t 以外的任何整型`。比如:

  ```c++
  enum class Colors :char { Red, Green, Blue };
  ```

  > ==**wchar_t 是什么?**==
  >
  > - ==双字节类型，或宽字符类型，是C/C++的一种扩展的存储方式，一般为16位或32位，所能表示的字符数远超char型。==
  > - ==主要用在国际化程序的实现中，但它不等同于 unicode 编码。unicode 编码的字符一般以wchar_t类型存储。==

了解了强类型枚举的优势之后，我们再看一段程序：

```c++
enum class China { Shanghai, Dongjing, Beijing, Nanjing, };
enum class Japan:char { Dongjing, Daban, Hengbin, Fudao };
int main()
{
    int m = Shanghai;           // error
    int n = China::Shanghai;    // error
    if ((int)China::Beijing >= 2)
    {
    	cout << "ok!" << endl;
    }
    cout << "size1: " << sizeof(China::Dongjing) << endl;  // 4
    cout << "size2: " << sizeof(Japan::Dongjing) << endl;  // 1
    return 0;
}
```

- 第5行：该行的代码有两处错误
  1. 强类型枚举属于强作用于类型，不能直接使用，枚举值前必须加枚举类型
  2. 强类型枚举不会进行隐式类型转换，因此枚举值不能直接给`int`行变量赋值（虽然强类型枚举的枚举值默认就是整形，但其不能作为整形使用）。
- 第6行：语法错误，将强类型枚举值作为整形使用，此处不会进行隐式类型转换
- 第7行：语法正确，强类型枚举值在和整数比较之前做了强制类型转换。
- 第11行：`打印的结果为4`，强类型枚举底层类型值默认为`int`，因此占用的内存是4个字节
- 第12行：`打印的结果为1`，显示指定了强类型枚举值的类型为`char`，因此占用的内存大小为1个字节，这样我们就可以节省更多的内存空间了。

### 11.2.2 对原有枚举的扩展

相比于原来的枚举，强类型枚举更像是一个属于C++的枚举。但为了配合新的枚举类型，C++11还对原有枚举类型进行了扩展：

1. 原有枚举类型的底层类型在默认情况下，仍然由编译器来具体指定实现。但也可以跟强类型枚举类一样，显式地由程序员来指定。其指定的方式跟强类型枚举一样，都是枚举名称后面加上`∶type`，其中`type 可以是除 wchar_t 以外的任何整型`。比如∶

   ```c++
   enum Colors : char { Red, Green, Blue };
   ```

2. 关于作用域，在C++11中，枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效。比如：

   ```c++
   enum Colors : char { Red, Green, Blue };
   int main()
   {
       Colors c1 = Green;          // C++11以前的用法
       Colors c2 = Colors::Green;  // C++11的扩展语法
       return 0;
   }
   ```

   上面程序中第4、5行的写法都是合法的。

C++11中对原有枚举类型的这两个扩展都保留了向后兼容性，也方便了程序员在代码中同时操作两种枚举类型。此外，我们在声明强类型枚举的时候，也可以使用关键字`enum struct`。实际上 `enum struct `和`enum class`在语法上没有任何区别（**==enum class 的成员没有公有私有之分，也不会使用模板来支持泛化的声明==** ）。

# 12、非受限联合体

## 12.1 什么是非受限联合体

**联合体**又叫**共用体**，我将其称之为`union`，它的使用方式和结构体类似，程序猿可以在联合体内部定义多种不同类型的数据成员，但是**这些数据会共享同一块内存空间**（也就是**如果对多个数据成员同时赋值会发生数据的覆盖**）。在某些特定的场景下，通过这种特殊的数据结构我们就可以实现内存的复用，从而达到节省内存空间的目的。

在C++11之前我们使用的联合体是有局限性的，主要有以下三点：

1. 不允许联合体拥有**非POD类型**的成员
2. 不允许联合体拥有静态成员
3. 不允许联合体拥有引用类型的成员

在新的C++11标准中，取消了关于联合体对于数据成员类型的限定，规定**任何非引用类型都可以成为联合体的数据成员，这样的联合体称之为==非受限联合体（Unrestricted Union）==**

## 12.2 非受限联合体的使用

### 12.2.1 静态类型的成员

对于非受限联合体来说，静态成员有两种分别是`静态成员变量`和`静态成员函数`，我们来看一下下面的代码：

```c++
union Test
{
    int age;
    long id;
    // int& tmp = age; // error
    static char c; // 静态成员变量与联合体的其他成员不同，它并不共享内存。因此，静态成员变量 c 和 age、id 是 独立的，并且 不共享内存。
    static int print()
    {
        cout << "c value: " << c << endl;
        return 0;
    }
};
char Test::c; // 受限联合体中的静态成员变量需要在非受限联合体外部声明（第13行）或者初始化（第14行）之后才能使用
// char Test::c = 'a';

int main()
{
    Test t;
    Test t1;
    t.c = 'b';  
    t1.c = 'c'; 
    t1.age = 666;
    cout << "t.c: " << t.c << endl;
    cout << "t1.c: " << t1.c << endl;
    cout << "t1.age: " << t1.age << endl;
    cout << "t1.id: " << t1.id << endl;
    t.print();
    Test::print();
    return 0;
}
```

执行程序输出的结果如下:

```c++
t.c: c
t1.c: c
t1.age: 666
t1.id: 666
c value: c
c value: c
```

接下来我们逐一分析一下上面的代码:

- 第5行：语法错误，`非受限联合体中不允许出现引用类型`
- 第6行：非受限联合体中的静态成员变量
  1. 需要在非受限联合体外部声明（第13行）或者初始化（第14行）之后才能使用
  2. 通过打印的结果可以发现18、19行的`t`和`t1`对象共享这个静态成员变量（和类 class/struct 中的静态成员变量的使用是一样的）。
- 第7行：非受限联合体中的静态成员函数
  1. 在静态函数`print()`只能访问非受限联合体`Test`中的静态变量，对于非静态成员变量（`age、id`）是无法访问的。
  2. 调用这个静态方法可以通过对象（第27行）也可以通过类名（第28行）实现。
- 第24、25、26行：通过打印的结果可以得出结论`在非受限联合体中静态成员变量和非静态成员变量使用的不是同一块内存。`

### 12.2.2 非POD类型成员

在 C++11标准中会默认删除一些非受限联合体的默认函数。比如，非受限联合体`有一个非 POD 的成员`，而该非 POD成员类型拥有 **非平凡的构造函数**，那么`非受限联合体的默认构造函数将被编译器删除`。其他的特殊成员函数，例如`默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将遵从此规则`。下面来举例说明：

```c++
union Student
{
    int id;
    string name;
};

int main()
{
    Student s;
    return 0;
}
```

编译程序会看到如下的错误提示:

```c++
warning C4624: “Student”: 已将析构函数隐式定义为“已删除”
error C2280: “Student::Student(void)”: 尝试引用已删除的函数
```

上面代码中的非受限联合体`Student`中拥有一个非PDO类型的成员`string name`，`string 类`中有非平凡构造函数，因此`Student`的构造函数被删除（通过警告信息可以得知它的析构函数也被删除了）导致对象无法被成功创建出来。解决这个问题的办法就是`由程序猿自己为非受限联合体定义构造函数`，在定义构造函数的时候我们需要用到`定位放置 new`操作。

#### **placement new**

一般情况下，使用new申请空间时，是从系统的`堆（heap）`中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做`placement new`即`定位放置 new`。

定位放置new操作的语法形式不同于普通的new操作：

- 使用new申请内存空间：`Base* ptr = new Base;`

- 使用定位放置new申请内存空间：

  ```c++
  ClassName* ptr = new (定位的内存地址)ClassName;
  ```

我们来看下面的示例程序:

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    Base() {}
    ~Base() {}
    void print()
    {
        cout << "number value: " << number << endl;
    }
private:
    int number;
};

int main()
{
    int n = 100;
    Base* b = new (&n)Base;
    b->print();
    return 0;
}
```

程序运行输出的结果为:

```c++
number value: 100
```

在程序的第20行，使用定位放置的方式为指针`b`申请了一块内存，也就是说此时`指针 b`指向的内存地址和`变量 n`对应的内存地址是同一块（栈内存），而在`Base类`中`成员变量 number`的起始地址和`Base对象`的起始地址是相同的，所以打印出 number 的值为100也就是整形变量 n 的值。

最后，给大家总结一下关于`placement new`的一些细节：

1. **使用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象，这取决于定位时指定的内存地址是在堆还是在栈上。**
2. **从表面上看，定位放置new操作是申请空间，其本质是利用已经申请好的空间，真正的申请空间的工作是在此之前完成的。**
3. **使用定位放置new 创建对象时会自动调用对应类的构造函数，但是由于对象的空间不会自动释放，如果需要释放堆内存必须显示调用类的析构函数。**
4. **使用定位放置new操作，我们可以反复动态申请到同一块堆内存，这样可以避免内存的重复创建销毁，从而提高程序的执行效率（比如网络通信中数据的接收和发送）。**

#### 自定义非受限联合体构造函数

掌握了`placement new`的使用，我们通过一段程序来演示一下如果在非受限联合体中自定义构造函数：

```c++
class Base
{
public:
    void setText(string str)
    {
        notes = str;
    }
    void print()
    {
        cout << "Base notes: " << notes << endl;
    }
private:
    string notes;
};

union Student
{
    Student()
    {
        new (&name)string;
    }
    ~Student() {}

    int id;
    Base tmp;
    string name;
};

int main()
{
    Student s;
    s.name = "蒙奇·D·路飞";
    s.tmp.setText("我是要成为海贼王的男人!");
    s.tmp.print();
    cout << "Student name: " << s.name << endl;
    return 0;
}
```

程序打印的结果如下：

```c++
Base notes: 我是要成为海贼王的男人!
Student name: 我是要成为海贼王的男人!
```

我们在上面的程序里边给非受限制联合体显示的指定了构造函数和析构函数，在程序的第31行需要创建一个非受限联合体对象，这时便调用了联合体内部的构造函数，在构造函数的第20行通过`定位放置 new`的方式将构造出的对象地址定位到了联合体的成员`string name`的地址上了，这样联合体内部其他非静态成员也就可以访问这块地址了（通过输出的结果可以看到对联合体内的tmp对象赋值，会覆盖name对象中的数据）。

#### 匿名的非受限联合体

一般情况下我们使用的非受限联合体都是具名的（有名字），但是我们也可以定义匿名的非受限联合体，一个比较实用的场景就是配合着类的定义使用。我们来设定一个场景：

```c++
木叶村要进行第99次人口普查，人员的登记方式如下：
    - 学生只需要登记所在学校的编号
    - 本村学生以外的人员需要登记其身份证号码
    - 本村外来人员需要登记户口所在地+联系方式
c++

// 外来人口信息
struct Foreigner
{
    Foreigner(string s, string ph) : addr(s), phone(ph) {}
    string addr;
    string phone;
};

// 登记人口信息
class Person
{
public:
    enum class Category : char {Student, Local, Foreign};
    Person(int num) : number(num), type(Category::Student) {}
    Person(string id) : idNum(id), type(Category::Local) {}
    Person(string addr, string phone) : foreign(addr, phone), type(Category::Foreign) {}
    ~Person() {}

    void print()
    {
        cout << "Person category: " << (int)type << endl;
        switch (type)
        {
        case Category::Student:
            cout << "Student school number: " << number << endl;
            break;
        case Category::Local:
            cout << "Local people ID number: " << idNum << endl;
            break;
        case Category::Foreign:
            cout << "Foreigner address: " << foreign.addr
                << ", phone: " << foreign.phone << endl;
            break;
        default:
            break;
        }
    }

private:
    Category type;
    union
    {
        int number;
        string idNum;
        Foreigner foreign;
    };
};

int main()
{
    Person p1(9527);
    Person p2("1101122022X");
    Person p3("砂隐村村北", "1301810001");
    p1.print();
    p2.print();
    p3.print();
    return 0;
}
```

程序输出的结果：

```c++
Person category: 0
Student school number: 9527
Person category: 1
Local people ID number: 1101122022X
Person category: 2
Foreigner address: 砂隐村村北, phone: 1301810001
```

根据需求我们将木叶村的人口分为了三类并通过枚举记录了下来，在`Person类`中添加了一个匿名的非受限联合体用来存储人口信息，仔细分析之后就会发现这种处理方式的优势非常明显：`尽可能地节省了内存空间。`

- `Person类`可以直接访问匿名非受限联合体内部的数据成员。
- 不使用匿名非受限联合体申请的内存空间等于 `number、 idNum 、 foreign 三者内存之和`。
- 使用匿名非受限联合体之后`number、 idNum 、 foreign 三者共用同一块内存`。

PS：流氓头子360会阻止这段代码生成的可执行程序的运行，哈哈哈。。。

# 第四篇——安全性

# 1、共享智能指针

在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。`智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。`

C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件`<memory>`：

- `std::shared_ptr`：共享的智能指针
- `std::unique_ptr`：独占的智能指针
- `std::weak_ptr`：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。

## 1.1 shared_ptr的初始化

共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行**初始化**有三种方式：**通过构造函数**、**std::make_shared辅助函数**以及**reset方法**。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数`use_count`，函数原型如下：

```c++
// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。
long use_count() const noexcept;
```

### 1.1.1 通过构造函数初始化

```c++
// shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:
std::shared_ptr<T> 智能指针名字(创建堆内存);
```

测试代码如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    // 使用智能指针管理一块 int 型的堆内存
    shared_ptr<int> ptr1(new int(520));
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;  // 1
    // 使用智能指针管理一块字符数组对应的堆内存
    shared_ptr<char> ptr2(new char[12]);
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;  // 1
    // 创建智能指针对象, 不管理任何内存
    shared_ptr<int> ptr3;
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;  // 0
    // 创建智能指针对象, 初始化为空
    shared_ptr<int> ptr4(nullptr);
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;  // 0

    return 0;
}
```

测试代码输出的结果如下:

```c++
ptr1管理的内存引用计数: 1
ptr2管理的内存引用计数: 1
ptr3管理的内存引用计数: 0
ptr4管理的内存引用计数: 0
```

> **==如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个shared_ptr。==**

```c++
int *p = new int;
shared_ptr<int> p1(p);
shared_ptr<int> p2(p);		// error, 编译不会报错, 运行会出错
// 主要是因为 shared_ptr 管理的对象是通过引用计数来管理的，若同一个裸指针 (p) 被多个 shared_ptr 对象管理，就会导致 双重释放（double free）问题，从而导致程序崩溃或未定义行为
```

### 1.1.2 通过拷贝和移动构造函数初始化

当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。

```c++
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr<int> ptr1(new int(520));
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;  // 1，初始时只有 ptr1 管理着这块内存，所以引用计数为 1。
    // 调用拷贝构造函数
    shared_ptr<int> ptr2(ptr1);
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;  // 2，ptr1 和 ptr2 都是同一块内存的所有者
    shared_ptr<int> ptr3 = ptr1;
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;  // 3，ptr3 是通过拷贝赋值从 ptr1 初始化的。此时，ptr1、ptr2 和 ptr3 都管理同一块内存。
    // 调用移动构造函数
    shared_ptr<int> ptr4(std::move(ptr1));
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;  // 3，std::move(ptr1) 将 ptr1 的所有权转移给 ptr4。移动构造后，ptr1 成为一个空指针（nullptr），不再管理那块内存
    shared_ptr<int> ptr5 = std::move(ptr2);
    cout << "ptr5管理的内存引用计数: " << ptr5.use_count() << endl;  // 3，std::move(ptr2) 将 ptr2 的所有权转移给 ptr5，ptr2 被置为空指针（nullptr）。

    return 0;
}
```

测试程序输入的结果：

```c++
ptr1管理的内存引用计数: 1
ptr2管理的内存引用计数: 2
ptr3管理的内存引用计数: 3
ptr4管理的内存引用计数: 3
ptr5管理的内存引用计数: 3
```

> **==如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。==**

### 1.1.3 通过std::make_shared初始化

通过C++提供的std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：

```c++
template< class T, class... Args >
shared_ptr<T> make_shared( Args&&... args );
```

- `T`：模板参数的数据类型
- `Args&&... args `：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定

测试代码如下:

```c++
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class Test
{
public:
    Test() 
    {
        cout << "construct Test..." << endl;
    }
    Test(int x) 
    {
        cout << "construct Test, x = " << x << endl;
    }
    Test(string str) 
    {
        cout << "construct Test, str = " << str << endl;
    }
    ~Test()
    {
        cout << "destruct Test ..." << endl;
    }
};

int main()
{
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr<int> ptr1 = make_shared<int>(520);
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;

    shared_ptr<Test> ptr2 = make_shared<Test>();
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;

    shared_ptr<Test> ptr3 = make_shared<Test>(520);
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;

    shared_ptr<Test> ptr4 = make_shared<Test>("我是要成为海贼王的男人!!!");
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;
    return 0;
}

输出：
ptr1管理的内存引用计数: 1
construct Test...
ptr2管理的内存引用计数: 1
construct Test, x = 520
ptr3管理的内存引用计数: 1
construct Test, str = 我是要成为海贼王的男人!!!
ptr4管理的内存引用计数: 1
destruct Test ...
destruct Test ...
destruct Test ...
```

使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。

### 1.1.4 通过 reset方法初始化

共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：

```c++
void reset() noexcept;

template< class Y >
void reset( Y* ptr );

template< class Y, class Deleter >
void reset( Y* ptr, Deleter d );

template< class Y, class Deleter, class Alloc >
void reset( Y* ptr, Deleter d, Alloc alloc );
```

- **ptr**：指向要取得所有权的对象的指针
- **d**：指向要取得所有权的对象的指针
- **aloc**：内部存储所用的分配器

测试代码如下：

```c++
#include <iostream>
#include <string>
#include <memory>
using namespace std;

int main()
{
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr<int> ptr1 = make_shared<int>(520);
    shared_ptr<int> ptr2 = ptr1;
    shared_ptr<int> ptr3 = ptr1;
    shared_ptr<int> ptr4 = ptr1;
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;  // 4
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;  // 4
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;  // 4
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;  // 4

    ptr4.reset();
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;  // 3
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;  // 3
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;  // 3
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;  // 0

    shared_ptr<int> ptr5;
    ptr5.reset(new int(250));
    cout << "ptr5管理的内存引用计数: " << ptr5.use_count() << endl;  // 1

    return 0;
}
```

测试代码输入的结果:

```c++
ptr1管理的内存引用计数: 4
ptr2管理的内存引用计数: 4
ptr3管理的内存引用计数: 4
ptr4管理的内存引用计数: 4
    
ptr1管理的内存引用计数: 3
ptr2管理的内存引用计数: 3
ptr3管理的内存引用计数: 3
ptr4管理的内存引用计数: 0
    
ptr5管理的内存引用计数: 1
```

> **==对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。==**

### 1.1.5 获取原始指针

通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的`get()`方法，其函数原型如下：

```c++
T* get() const noexcept;
```

测试代码如下:

```c++
#include <iostream>
#include <string>
#include <memory>
using namespace std;

int main()
{
    int len = 128;
    shared_ptr<char> ptr(new char[len]);
    // 得到指针的原始地址
    char* add = ptr.get();
    memset(add, 0, len);  // 将内存块中的前 len 个字节全部设置为0
    strcpy(add, "我是要成为海贼王的男人!!!");  // 将指定的字符串复制到 add 指向的内存区域
    cout << "string: " << add << endl;
    
    shared_ptr<int> p(new int);
    *p = 100;
    cout << *p.get() << "  " << *p << endl;
    
    return 0;
}

输出：
string: 我是要成为海贼王的男人!!!
100  100
```

## 1.2 指定删除器

当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为**删除器**，这个删除器函数**本质是一个回调函数**，我们只需要进行实现，其调用是由智能指针完成的。

```c++
#include <iostream>
#include <memory>
using namespace std;

// 自定义删除器函数，释放int型内存
void deleteIntPtr(int* p)
{
    delete p;
    cout << "int 型内存被释放了...";
}

int main()
{
    shared_ptr<int> ptr(new int(250), deleteIntPtr);
    return 0;
}
```

删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：

```c++
int main()
{
    shared_ptr<int> ptr(new int(250), [](int* p) {delete p; });
    return 0;
}
```

在上面的代码中，`lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。`

在C++11中使用shared_ptr管理动态数组时，需要指定删除器，因为`std::shared_ptr的默认删除器不支持数组对象`，具体的处理代码如下：

```c++
int main()
{
    shared_ptr<int> ptr(new int[10], [](int* p) {delete[]p; });
    return 0;
}
```

在删除数组内存时，除了自己编写删除器，也可以使用C++提供的`std::default_delete<T>()`函数作为删除器，这个函数内部的删除功能也是通过调用`delete`来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：

```c++
int main()
{
    shared_ptr<int> ptr(new int[10], default_delete<int[]>());
    return 0;
}
```

另外，我们还可以自己封装一个make_shared_array方法来让shared_ptr支持数组，代码如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

template <typename T>
shared_ptr<T> make_share_array(size_t size)
{
    // 返回匿名对象
    return shared_ptr<T>(new T[size], default_delete<T[]>());
}

int main()
{
    shared_ptr<int> ptr1 = make_share_array<int>(10);
    cout << ptr1.use_count() << endl;
    shared_ptr<char> ptr2 = make_share_array<char>(128);
    cout << ptr2.use_count() << endl;
    return 0;
}
```

# 2、独占的智能指针

在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。`智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。`

C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件`<memory>`：

- `std::shared_ptr`：共享的智能指针
- `std::unique_ptr`：独占的智能指针
- `std::weak_ptr`：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。

## 2.1 初始化

std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。

```c++
// 通过构造函数初始化对象
unique_ptr<int> ptr1(new int(10));
// error, 不允许将一个unique_ptr赋值给另一个unique_ptr
unique_ptr<int> ptr2 = ptr1;
```

std::unique_ptr不允许复制，但是可以通过函数返回给其他的std::unique_ptr，还可以通过**std::move**来转译给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。

```c++
#include <iostream>
#include <memory>
using namespace std;

unique_ptr<int> func()
{
    return unique_ptr<int>(new int(520));
}

int main()
{
    // 通过构造函数初始化
    unique_ptr<int> ptr1(new int(10));
    // 通过转移所有权的方式初始化
    unique_ptr<int> ptr2 = move(ptr1);
    unique_ptr<int> ptr3 = func();

    return 0;
}
```

unique_ptr独占智能指针类也有一个**reset**方法，函数原型如下：

```c++
void reset( pointer ptr = pointer() ) noexcept;
```

使用reset方法可以让unique_ptr解除对原始内存的管理，也可以用来初始化一个独占的智能指针。

```c++
int main()
{
    unique_ptr<int> ptr1(new int(10));
    unique_ptr<int> ptr2 = move(ptr1);

    ptr1.reset();
    ptr2.reset(new int(250));

    return 0;
}
```

- `ptr1.reset();`解除对原始内存的管理
- `ptr2.reset(new int(250));`重新指定智能指针管理的原始内存

如果想要获取独占智能指针管理的原始地址，可以调用get()方法，函数原型如下：

```c++
pointer get() const noexcept;
```

```c++
int main()
{
    unique_ptr<int> ptr1(new int(10));
    unique_ptr<int> ptr2 = move(ptr1);

    ptr2.reset(new int(250));
    cout << *ptr2.get() << endl;	// 得到内存地址中存储的实际数值 250

    return 0;
}
```

## 2.2 删除器

unique_ptr指定删除器和shared_ptr指定删除器是有区别的，unique_ptr指定删除器的时候**需要确定删除器的类型**，所以不能像shared_ptr那样直接指定删除器，举例说明：

```c++
shared_ptr<int> ptr1(new int(10), [](int*p) {delete p; });	// ok
unique_ptr<int> ptr1(new int(10), [](int*p) {delete p; });	// error

int main()
{
    using func_ptr = void(*)(int*);
    unique_ptr<int, func_ptr> ptr1(new int(10), [](int*p) {delete p; });

    return 0;
}
```

在上面的代码中第7行，`func_ptr`的类型和`lambda表达式`的类型是一致的。在lambda表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：

```c++
int main()
{
    using func_ptr = void(*)(int*);
    unique_ptr<int, func_ptr> ptr1(new int(10), [&](int*p) {delete p; });	// error
    return 0;
}
```

上面的代码中错误原因是这样的，在lambda表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：

```c++
int main()
{
    using func_ptr = void(*)(int*);
    unique_ptr<int, function<void(int*)>> ptr1(new int(10), [&](int*p) {delete p; });
    return 0;
}
```

# 3、弱引用智能指针

在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。

C++11 中提供了三种智能指针，使用这些智能指针时需要引用头文件 ：

**std::shared_ptr：共享的智能指针**
**std::unique_ptr：独占的智能指针**
**std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 shared_ptr 的。**

## 3.1 基本使用方法

弱引用智能指针`std::weak_ptr`可以看做是`shared_ptr`的助手，它不管理`shared_ptr`内部的指针。`std::weak_ptr`没有重载操作符`*`和`->`，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视`shared_ptr`中管理的资源是否存在。

### 3.1.1 初始化

```c++
// 默认构造函数
constexpr weak_ptr() noexcept;
// 拷贝构造
weak_ptr (const weak_ptr& x) noexcept;
template <class U> weak_ptr (const weak_ptr<U>& x) noexcept;
// 通过shared_ptr对象构造
template <class U> weak_ptr (const shared_ptr<U>& x) noexcept;
```

在C++11中，`weak_ptr`的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> sp(new int);

    weak_ptr<int> wp1;
    weak_ptr<int> wp2(wp1);
    weak_ptr<int> wp3(sp);
    weak_ptr<int> wp4;
    wp4 = sp;
    weak_ptr<int> wp5;
    wp5 = wp3;
    
    return 0;
}
```

- `weak_ptr<int> wp1;`构造了一个空`weak_ptr`对象
- `weak_ptr<int> wp2(wp1);`通过一个空`weak_ptr`对象构造了另一个空`weak_ptr`对象
- `weak_ptr<int> wp3(sp);`通过一个`shared_ptr`对象构造了一个可用的`weak_ptr`实例对象
- `wp4 = sp;`通过一个`shared_ptr`对象构造了一个可用的`weak_ptr`实例对象（这是一个隐式类型转换）
- `wp5 = wp3;`通过一个`weak_ptr`对象构造了一个可用的`weak_ptr`实例对象

### 3.1.2 其他常用方法

#### 3.1.2.1 use_count()

通过调用`std::weak_ptr`类提供的`use_count()`方法可以获得当前所观测资源的引用计数，函数原型如下：

```c++
// 函数返回所监测的资源的引用计数
long int use_count() const noexcept;
```

修改一下上面的测试程序，添加打印资源引用计数的代码：

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> sp(new int);

    weak_ptr<int> wp1;
    weak_ptr<int> wp2(wp1);
    weak_ptr<int> wp3(sp);
    weak_ptr<int> wp4;
    wp4 = sp;
    weak_ptr<int> wp5;
    wp5 = wp3;

    cout << "use_count: " << endl;
    cout << "wp1: " << wp1.use_count() << endl;
    cout << "wp2: " << wp2.use_count() << endl;
    cout << "wp3: " << wp3.use_count() << endl;
    cout << "wp4: " << wp4.use_count() << endl;
    cout << "wp5: " << wp5.use_count() << endl;
    return 0;
}
```

测试程序输出的结果为:

```c++
use_count:
wp1: 0
wp2: 0
wp3: 1
wp4: 1
wp5: 1
```

通过打印的结果可以知道，虽然弱引用智能指针`wp3`、`wp4`、`wp5`监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了`weak_ptr只是监测资源，并不管理资源`。

#### 3.1.2.3 expired()

通过调用`std::weak_ptr`类提供的`expired()`方法来判断观测的资源是否已经被释放，函数原型如下：

```c++
// 返回true表示资源已经被释放, 返回false表示资源没有被释放
bool expired() const noexcept;
```

函数的使用方法如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> shared(new int(10));
    weak_ptr<int> weak(shared);
    cout << "1. weak " << (weak.expired() ? "is" : "is not") << " expired" << endl;

    shared.reset();
    cout << "2. weak " << (weak.expired() ? "is" : "is not") << " expired" << endl;

    return 0;
}
```

测试代码输出的结果:

```c++
1. weak is not expired
2. weak is expired
```

`weak_ptr`监测的就是`shared_ptr`管理的资源，当共享智能指针调用`shared.reset();`之后管理的资源被释放，因此`weak.expired()`函数的结果返回`true`，表示监测的资源已经不存在了。

#### 3.1.2.3 lock()

通过调用`std::weak_ptr`类提供的`lock()`方法来获取管理所监测资源的`shared_ptr`对象，函数原型如下：

```c++
shared_ptr<element_type> lock() const noexcept;
```

函数的使用方法如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    shared_ptr<int> sp1, sp2;
    weak_ptr<int> wp;

    sp1 = std::make_shared<int>(520);
    wp = sp1;
    sp2 = wp.lock();
    cout << "use_count: " << wp.use_count() << endl;

    sp1.reset();
    cout << "use_count: " << wp.use_count() << endl;

    sp1 = wp.lock();
    cout << "use_count: " << wp.use_count() << endl;

    cout << "*sp1: " << *sp1 << endl;
    cout << "*sp2: " << *sp2 << endl;

    return 0;
}
```

测试代码输出的结果为:

```c++
use_count: 2
use_count: 1
use_count: 2
*sp1: 520
*sp2: 520
```

- `sp2 = wp.lock();`通过调用`lock()`方法得到一个用于管理`weak_ptr`对象所监测的资源的共享智能指针对象，使用这个对象初始化`sp2`，此时所监测资源的引用计数为`2`
- `sp1.reset();`共享智能指针sp1被重置，`weak_ptr`对象所监测的资源的引用计数减1
- `sp1 = wp.lock();`sp1重新被初始化，并且管理的还是`weak_ptr`对象所监测的资源，因此引用计数加1
- 共享智能指针对象`sp1`和`sp2`管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是520

#### 3.1.2.4 reset()

通过调用`std::weak_ptr`类提供的`reset()`方法来清空对象，使其不监测任何资源，函数原型如下：

```c++
void reset() noexcept;
```

函数的使用是非常简单的，示例代码如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> sp(new int(10));
    weak_ptr<int> wp(sp);
    cout << "1. wp " << (wp.expired() ? "is" : "is not") << " expired" << endl;

    wp.reset();
    cout << "2. wp " << (wp.expired() ? "is" : "is not") << " expired" << endl;

    return 0;
}
```

测试代码输出的结果为:

```c++
1. wp is not expired
2. wp is expired
weak_ptr`对象`sp`被重置之后`wp.reset();`变成了空对象，不再监测任何资源，因此`wp.expired()`返回`true
```

## 3.2 返回管理this的shared_ptr

如果在一个类中编写了一个函数，通过这个得到管理当前对象的共享智能指针，我们可能会写出如下代码：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct Test
{
    shared_ptr<Test> getSharedPtr()
    {
        return shared_ptr<Test>(this);
    }
    
    ~Test()
    {
        cout << "class Test is disstruct ..." << endl;
    }

};

int main() 
{
    shared_ptr<Test> sp1(new Test);
    cout << "use_count: " << sp1.use_count() << endl;
    shared_ptr<Test> sp2 = sp1->getSharedPtr();
    cout << "use_count: " << sp1.use_count() << endl;
    return 0;
}
```

执行上面的测试代码，运行中会出现异常，在终端还是能看到对应的日志输出：

```c++
use_count: 1
use_count: 1
class Test is disstruct ...
class Test is disstruct ...
```

通过输出的结果可以看到`一个对象被析构了两次`，其原因是这样的：在这个例子中使用同一个指针`this`构造了两个智能指针对象`sp1`和`sp2`，这二者之间是没有任何关系的，因为`sp2`并不是通过`sp1`初始化得到的实例对象。在离开作用域之后`this`将被构造的两个智能指针各自析构，导致重复析构的错误。

这个问题可以通过`weak_ptr`来解决，通过`wek_ptr`返回管理`this`资源的共享智能指针对象`shared_ptr`。C++11中为我们提供了一个模板类叫做`std::enable_shared_from_this<T>`，这个类中有一个方法叫做`shared_from_this()`，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用`weak_ptr`来监测`this`对象，并通过调用`weak_ptr`的`lock()`方法返回一个`shared_ptr`对象。

修改之后的代码为：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct Test : public enable_shared_from_this<Test>
{
    shared_ptr<Test> getSharedPtr()
    {
        return shared_from_this();
    }
    ~Test()
    {
        cout << "class Test is disstruct ..." << endl;
    }
};

int main() 
{
    shared_ptr<Test> sp1(new Test);
    cout << "use_count: " << sp1.use_count() << endl;
    shared_ptr<Test> sp2 = sp1->getSharedPtr();
    cout << "use_count: " << sp1.use_count() << endl;
    return 0;
}
```

测试代码输出的结果为:

```c++
use_count: 1
use_count: 2
class Test is disstruct ...
```

最后需要强调一个细节：在调用enable_shared_from_this类的shared_from_this()方法之前，必须要先初始化函数内部weak_ptr对象，否则该函数无法返回一个有效的shared_ptr对象（具体处理方法可以参考上面的示例代码）。

## 3.3 解决循环引用问题

智能指针如果循环引用会导致内存泄露，比如下面的例子：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct TA;
struct TB;

struct TA
{
    shared_ptr<TB> bptr;
    ~TA()
    {
        cout << "class TA is disstruct ..." << endl;
    }
};

struct TB
{
    shared_ptr<TA> aptr;
    ~TB()
    {
        cout << "class TB is disstruct ..." << endl;
    }
};

void testPtr()
{
    shared_ptr<TA> ap(new TA);
    shared_ptr<TB> bp(new TB);
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

    ap->bptr = bp;
    bp->aptr = ap;
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;
}

int main()
{
    testPtr();
    return 0;
}
```

测试程序输出的结果如下:

```c++
TA object use_count: 1
TB object use_count: 1
TA object use_count: 2
TB object use_count: 2
```

在测试程序中，共享智能指针`ap`、`bp`对`TA`、`TB`实例对象的引用计数变为2，`在共享智能指针离开作用域之后引用计数只能减为1`，这种情况下不会去删除智能指针管理的内存，导致类`TA`、`TB`的实例对象不能被析构，最终造成内存泄露。通过使用`weak_ptr`可以解决这个问题，只要将类`TA`或者`TB`的任意一个成员改为`weak_ptr`，修改之后的代码如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct TA;
struct TB;

struct TA
{
    weak_ptr<TB> bptr;
    ~TA()
    {
        cout << "class TA is disstruct ..." << endl;
    }
};

struct TB
{
    shared_ptr<TA> aptr;
    ~TB()
    {
        cout << "class TB is disstruct ..." << endl;
    }
};

void testPtr()
{
    shared_ptr<TA> ap(new TA);
    shared_ptr<TB> bp(new TB);
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

    ap->bptr = bp;
    bp->aptr = ap;
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;
}

int main()
{
    testPtr();
    return 0;
}
```

程序输出的结果:

```c++
TA object use_count: 1
TB object use_count: 1
TA object use_count: 2
TB object use_count: 1
class TB is disstruct ...
class TA is disstruct ...
```

通过输出的结果可以看到类`TA`或者`TB`的对象被成功析构了。

上面程序中，在对类`TA`成员赋值时`ap->bptr = bp;`由于`bptr`是`weak_ptr`类型，这个赋值操作并不会增加引用计数，所以`bp`的引用计数仍然为1，在离开作用域之后`bp`的引用计数减为0，类`TB`的实例对象被析构。

在类`TB`的实例对象被析构的时候，内部的`aptr`也被析构，其对`TA`对象的管理解除，内存的引用计数减为1，当共享智能指针`ap`离开作用域之后，对`TA`对象的管理也解除了，内存的引用计数减为0，类`TA`的实例对象被析构。

# 第五篇——多线程

# 1、处理日期和时间的chrono库













































































